:PROPERTIES:
:header-args:emacs-lisp: :tangle config.el :noweb yes :results silent :lexical yes :comments noweb
:END:
#+title: Carson's Emacs Config
* Introduction
This is my [[https:github.com/doomemacs/doomemacs][Doom Emacs]] configuration it has taken heavy inspiration from multiple
sources and is now and will always be a work in progress.

** Acknowledgments
Some sources of inspiration (and often times direct plagiarism) are as follows:

- [[https://sachachua.com/dotemacs/index.html][Sacha Chua's Emacs Config]]
- [[https:zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni's Emacs Config]]
- [[https:tecosaur.github.io/emacs-config/config.html][Tecosaur’s Emacs config]]

I highly recommend checking out these and other examples of Emacs configurations
as that's how I've learned all the best tips. Each configuration is highly
unique and many choices made here will be different than what you would pick
but it /works/ for me so I'll take no judgment.

In addition I'd like highlight the amazing Emacs videos and articles made by
David Wilson on his [[https://systemcrafters.net/][website]] and [[https://www.youtube.com/@SystemCrafters][youtube]] channel.
** File Layout
As this configuration is responsible for generating all my other emacs config
files it seems the most logical to get this out of the way early on. From this
configuration the following files are generated:

- =init.el=: Outlines what [[https:github.com/doomemacs/doomemacs/blob/develop/docs/getting_started.org#modules][doom modules]] will be enabled and other configuration
  that needs to occur early in the loading sequence, the majority of this can be
  found in the [[Doom Block]] section.
- =packages.el=: Outlines the packages to install and exactly how to install
  them when additional configuration is necessary.
- =config.el=: If it doesn't fit into the above categories than this is where
  it's gonna go typically is just the /general/ configuration.

Without any further preamble let's get to the configuration.
*** File Headers
To keep the headers of these files from cluttering the rest of this file they
are given here, they contain information that is automatically included when
installing doom and various other details about the file.

#+html: <details><summary>init.el</summary>
#+begin_src emacs-lisp :tangle init.el :comments no
;;; init.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src
#+html: </details>

#+html: <details><summary>packages.el</summary>
#+begin_src emacs-lisp :tangle packages.el :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;;(package! another-package
;;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;;(package! this-package
;;  :recipe (:host github :repo "username/repo"
;;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;;(package! builtin-package :recipe (:nonrecursive t))
;;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;;(package! builtin-package :pin "1a2b3c4d5e")

;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;;(unpin! pinned-package)
;; ...or multiple packages
;;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;;(unpin! t)
#+end_src

#+RESULTS:

#+html: </details>

#+html: <details><summary>config.el</summary>
#+begin_src emacs-lisp :tangle config.el :comments no
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
;; (setq user-full-name "John Doe"
;;      user-mail-address "john@doe.com")

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;; (setq doom-theme 'doom-one)

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
;; (setq org-directory "~/org/")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; (setq display-line-numbers-type t)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

#+RESULTS:

#+html: </details>

* Configuration Management
** Configuration Variables
#+begin_src emacs-lisp
(defvar doom-user-dir (expand-file-name "~/.config/doom")
  "
  This is the directory to which this configuration should tangle to mainly kept
  separate from `user-emacs-directory' so that I can have multiple configurations.
  ")
#+end_src

** Emacs Server
#+begin_src emacs-lisp
(use-package! server
  :demand t
  :config
  (unless (server-running-p)
    (server-start)))
#+end_src
** COMMENT MacOS Fixes
#+begin_src emacs-lisp
(when (string-equal system-type "darwin")
  (setq insert-directory-program "gls")
  (setq auth-source-pass-filename "~/.local/share/password-store"))
#+end_src

#+begin_src emacs-lisp :tangle early-init.el
(defun ch/read-local-settings ()
  (with-temp-buffer
    (shell-command "export" (current-buffer))
    (dolist (line (split-string
                   (substitute-env-vars (buffer-string))
                   "\n"))
      (cond
       ((not (string-match "\\(?:#.*\\|[ \t]*\\|\\)\\([^ =]+\\)=\\(.*\\)"
                             line))
        (message "Can't parse line: %S" line))
       ((not (match-beginning 1)) nil) ;; Comment or empty line.
       (t
        (setenv (match-string 1 line) (match-string 2 line)))))))

(ch/read-local-settings)
(getenv "PASSWORD_STORE_DIR")
#+end_src

** Utility Functions
#+begin_src emacs-lisp
(defun ch/add-list-to-list (original list)
  "Add the items in ~list~ to ~original~ using ~add-to-list~"
  (mapcar (lambda (item) (add-to-list original item)) list))

(defun ch/csv-to-list (path &optional col row)
  "
  Read the contents of a csv file located at PATH and transform it into a list
  of lists using COL, which defaults to \',\',  as the column seperator and ROW,
  which defaults to \'\\n\', as the row seperator.
  "
  (let ((col (or col ","))
	(row (or row "\n")))
    (mapcar
     #'(lambda (item)
	 (progn (s-trim item)
	        (s-split col item)))
     (s-split row (f-read path)))))

(defun ch/list-to-csv (tbl &optional col row)
  "
  Transform the contents of TBL, a list of lists, to a string in csv format using
  COL, which defaults to \',\',  as the column seperator and ROW,which defaults to
  \'\\n\',as the row seperator.
  "
  (let ((col (or col ","))
	(row (or row "\n")))
    (s-join row (mapcar #'(lambda (tbl-row) (s-join col tbl-row)) tbl))))

;; From https://emacs.stackexchange.com/questions/26251/one-time-advice
(defun advise-once (symbol where function &optional props)
  (advice-add symbol :after `(lambda (&rest _) (advice-remove ',symbol ',function)))
  (advice-add symbol where function props))

(advice-add 'pp-macroexpand-last-sexp :around
            (defun pp-macroexpand-last-sexp--around
                (orig-fun &rest orig-args)
              (pcase-let*
                  ((`(,arg)
                    orig-args)
                   (sexp (pp-last-sexp))
                   (env (append
                         (cond
                          ((eq 'use-package (car sexp))
                           `((use-package-expand-minimally ,(y-or-n-p "Minimal"))
                             (byte-compile-current-file ,(when (y-or-n-p "Byte compilation")
                                                           (current-buffer)))
                             (comment (format "&#12;
;; use-package-expand-minimally:         %S
;; byte-compile-current-file:            %S

"
                                              use-package-expand-minimally
                                              (null (null byte-compile-current-file))))))
                          (t
                           `((comment "")))))))
                ;; (message "%S" env)
                (eval `(let* ,env
                         (if ',arg
                             (save-excursion
                               (insert "\n\n")
                               (insert comment)
                               (apply ',orig-fun ',orig-args))
                           (apply ',orig-fun ',orig-args)))))))
#+end_src
* Modules
** Doom Block
This generates the ~doom!~ block of ~init.el~ which defines what should be
loaded into doom emacs. Currently I only rely on modules provided by doom itself
but any additions I may make will be described in their own section below the
doom block.
#+begin_src emacs-lisp :tangle init.el :lexical t
(setq doom-module-load-path
      '("/Users/carsonhenrich/.config/emacs/modules" "/Users/carsonhenrich/.config/doom/modules"))

(doom! :input
       ;;chinese
       ;;japanese
       ;;layout                                     ; auie,ctsrnm is the superior home row

       :completion
       (corfu +dabbrev +icons +orderless)
       (vertico +icons)                             ; the search engine of the future
       ;;(company)                                  ; the ultimate code completion backend
       ;;helm                                       ; the *other* search engine for love and life
       ;;ido                                        ; the other *other* search engine...
       ;;ivy                                        ; a search engine for love and life

       :ui
       (popup +defaults)                            ; tame sudden yet inevitable temporary windows
       ;; (treemacs)                                  ; a project drawer, like neotree but cooler
       (vc-gutter +pretty)                          ; vcs diff in the fringe
       doom                                         ; what makes DOOM look the way it does
       doom-dashboard                               ; a nifty splash screen for Emacs
       doom-quit                                    ; DOOM quit-message prompts when you quit Emacs
       hl-todo                                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       minimap                                      ; show a map of the code on the side
       modeline                                     ; snazzy, Atom-inspired modeline, plus API
       nav-flash                                    ; blink cursor line after big motions
       ophints                                      ; highlight the region an operation acts on
       ;;vi-tilde-fringe                              ; fringe tildes to mark beyond EOB
       window-select                                ; visually switch windows
       workspaces                                   ; tab emulation, persistence & separate workspaces
       zen                                          ; distraction-free coding or writing
       ;;unicode                                    ; extended unicode support for various languages
       ;;(ligatures +fira)                          ; ligatures or substitute text with pretty symbols
       ;;deft                                       ; notational velocity for Emacs
       ;;fill-column                                ; a `fill-column' indicator
       ;;hydra
       ;;indent-guides                              ; highlighted indent columns
       ;;neotree                                    ; a project drawer, like NERDTree for vim
       ;;tabs                                       ; a tab bar for Emacs

       :editor
       ;; (evil +everywhere)                           ; come to the dark side, we have cookies
       file-templates                               ; auto-snippets for empty files
       fold                                         ; (nigh) universal code folding
       format                                       ; automated prettiness
       multiple-cursors                             ; editing in many places at once
       ;; parinfer                                     ; turn lisp into python, sort of
       rotate-text                                  ; cycle region at point between text candidates
       snippets                                     ; my elves. They type so I don't have to
       ;;god                                        ; run Emacs commands without modifier keys
       ;;lispy                                      ; vim for lisp, for people who don't like vim
       ;;objed                                      ; text object editing for the innocent
       ;;word-wrap                                    ; soft wrapping with language-aware indent

       :emacs
       (dired +dirvish +icons)                      ; making dired pretty [functional]
       electric                                     ; smarter, keyword-based electric-indent
       ibuffer                                      ; interactive buffer management
       undo                                         ; persistent, smarter undo for your inevitable mistakes
       vc                                           ; version-control and Emacs, sitting in a tree

       :term
       eshell                                       ; the elisp shell that works everywhere
       vterm                                        ; the best terminal emulation in Emacs
       ;;shell                                      ; simple shell REPL for Emacs
       ;;term                                       ; basic terminal emulator for Emacs

       :checkers
       (spell +flyspell +hunspell)                  ; tasing you for misspelling mispelling
       (syntax +flymake)                            ; tasing you for every semicolon you forget
       grammar                                      ; tasing grammar mistake every you make

       :tools
       (:if (executable-find "ansible")
           (ansible))
       (:if (executable-find "docker")
           (docker +lsp))
       (:if (executable-find "git")                 ; a git porcelain for Emacs
           (magit +forge))
       (:if (executable-find "make")                ; run make tasks from Emacs
           (make))
       (:if (executable-find "pass")                ; password manager for nerds
           (pass +auth))
       (:if (executable-find "terraform")           ; infrastructure as code
           (terraform))
       (:if (executable-find "tmux")                ; an API for interacting with tmux
           (tmux))
       (eval +overlay)                              ; run code, run (also, repls)
       (lookup +dictionary +offline)                ; navigate your code and its documentation
       (lsp +peek +eglot)                           ; M-x vscode
       biblio                                       ; Writes a PhD for you (citation needed)
       debugger
       direnv
       pdf                                          ; pdf enhancements NOTE FOR MACOS https://github.com/politza/pdf-tools/issues/645#issuecomment-775496734
       tree-sitter                                  ; syntax and parsing, sitting in a tree...
       upload                                       ; map local to remote projects via ssh/ftp
       ;;(debugger +lsp)
       ;;collab                                     ; buffers with friends
       ;;editorconfig                               ; let someone else argue about tabs vs spaces
       ;;ein                                        ; tame Jupyter notebooks with emacs

       :os
       (:if IS-MAC macos)                           ; improve compatibility with macOS
       (tty +osc)                                   ; improve the terminal Emacs experience

       :lang
       (:if (executable-find "cargo")               ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
           (rust +tree-sitter +lsp))
       (:if (executable-find "kotlinc")             ; a better, slicker Java(Script)
           (kotlin +lsp))
       (:if (executable-find "nix")                 ; I hereby declare "nix geht mehr!"
           (nix +lsp +tree-sitter))
       (:if (executable-find "plantuml")            ; diagrams for confusing people more
           (plantuml))
       (:if (executable-find "go")                  ; the hipster dialect
           (go +tree-sitter +lsp))
       (cc +lsp)                                    ; C > C++ == 1
       (java +lsp)                                  ; the poster child for carpal tunnel syndrome
       (latex +latexmk +cdlatex +fold +lsp)         ; writing papers in Emacs has never been so fun
       (lua +lsp +tree-sitter)                      ; one-based indices? one-based indices
       (org +crypt +noter                           ; organize your plain life in plain text
            +present +pomodoro +roam2
            +dragndrop +pandoc)
       (python +tree-sitter +pyright +lsp)          ; beautiful is better than ugly
       (sh +lsp +fish +powershell)                  ; she sells {ba,z,fi}sh shells on the C xor
       data                                         ; config/data formats
       emacs-lisp                                   ; drown in parentheses
       javascript                                   ; all(hope(abandon(ye(who(enter(here))))))
       json                                         ; At least it ain't XML
       markdown                                     ; writing docs for people to ignore
       rest                                         ; Emacs as a REST client
       web                                          ; the tubes
       yaml                                         ; JSON, but readable
       ;;(dart +flutter)                            ; paint ui and not much else
       ;;(graphql +lsp)                             ; Give queries a REST
       ;;(haskell +lsp)                             ; a language that's lazier than I am
       ;;(ruby +rails)                              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;(scheme +guile)                            ; a fully conniving family of lisps
       ;;agda                                       ; types of types of types of types...
       ;;beancount                                  ; mind the GAAP
       ;;clojure                                    ; java with a lisp
       ;;common-lisp                                ; if you've seen one lisp, you've seen them all
       ;;coq                                        ; proofs-as-programs
       ;;crystal                                    ; ruby at the speed of c
       ;;csharp                                     ; unity, .NET, and mono shenanigans
       ;;dhall
       ;;elixir                                     ; erlang done right
       ;;elm                                        ; care for a cup of TEA?
       ;;erlang                                     ; an elegant language for a more civilized age
       ;;ess                                        ; emacs speaks statistics
       ;;factor
       ;;faust                                      ; dsp, but you get to keep your soul
       ;;fortran                                    ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp                                     ; ML stands for Microsoft's Language
       ;;fstar                                      ; (dependent) types and (monadic) effects and Z3
       ;;gdscript                                   ; the language you waited for
       ;;hy                                         ; readability of scheme w/ speed of python
       ;;idris                                      ; a language you can depend on
       ;;julia                                      ; a better, faster MATLAB
       ;;lean                                       ; for folks with too much to prove
       ;;ledger                                     ; be audit you can be
       ;;nim                                        ; python + lisp at the speed of c
       ;;ocaml                                      ; an objective camel
       ;;php                                        ; perl's insecure younger brother
       ;;purescript                                 ; javascript, but functional
       ;;qt                                         ; the 'cutest' gui framework ever
       ;;racket                                     ; a DSL for DSLs
       ;;raku                                       ; the artist formerly known as perl6
       ;;rst                                        ; ReST in peace
       ;;scala                                      ; java, but good
       ;;sml
       ;;solidity                                   ; do you need a blockchain? No.
       ;;swift                                      ; who asked for emoji variables?
       ;;terra                                      ; Earth and Moon in alignment for performance.
       ;;zig                                        ; C, but simpler

       :email
       (:if (executable-find "mu") (mu4e +org +gmail +mbsync))
       ;;(:if (executable-find "notmuch") (notmuch +org +afew))
       ;;(wanderlust +gmail)

       :app
       (rss +org)                                   ; emacs as an RSS reader
       calendar
       emms
       everywhere                                   ; *leave* Emacs!? You must be joking
       irc                                          ; how neckbeards socialize
       ;;twitter                                    ; twitter client https://twitter.com/vnought

       :config
       (default +smartparens)
       ;;literate


       :my_editor
       meow
       search
       :my_lang
       (org
        +roam
        +roam-ui
        +noter
        +pretty
        +query
        +present
        +hugo
        )
       :my_tools
       (:if (modulep! :email mu4e) mail)
       ;; grammarly
       (ai +whisper)
       )
#+end_src
** My_Lang
*** Org
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_lang/org/packages.el :lexical nil
:END:
Install packages required by this module according to other modules and flags set
#+begin_src emacs-lisp
;;; -*- no-byte-compile: t -*-
(package! nov)
(package! djvu)
(package! all-the-icons)
(package! ob-mermaid)
(package! engrave-faces)
(package! org-super-agenda)
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
(when (modulep! :lang kotlin) (package! ob-kotlin))


(when (modulep! :my_lang org +noter) (package! org-noter))
(when (modulep! :my_lang org +roam) (package! org-roam))
(when (modulep! :my_lang org +present) (package! org-present))
(when (modulep! :my_lang org +hugo) (package! ox-hugo))
(when (modulep! :my_lang org +pretty)
  (package! org-modern)
  (package! org-modern-indent
      :recipe
      (:host github
       :repo "jdtsmith/org-modern-indent"
       :files ("*.el" "filters" "preprocessors"))))
(when (modulep! :my_lang org +query)
  (package! org-ql)
  (when (modulep! :my_lang org +roam)
    (package! org-roam-ql)
    (package! org-roam-ql-ql)))
(when (modulep! :my_lang org +roam-ui)
  (package! org-roam-ui)
  (unpin! org-roam))
#+end_src

**** Checks
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_lang/org/doctor.el
:END:
#+begin_src emacs-lisp
(when (and (modulep! +noter) (not (modulep! :lang org +noter)))
  (warn! "The :my_lang org +noter flag is intended to be used with :lang org +noter, not doing so is undefined behavior"))
#+end_src

#+begin_src emacs-lisp
(when (and (modulep! +roam-ui) (not (modulep! +roam)))
  (error! "You are using the roam-ui flag without the roam flag, this is undefined behavior"))
#+end_src

**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_lang/org/config.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src
***** Org
#+begin_src emacs-lisp
(use-package! org
  :defer t
  :when (modulep! :my_lang org)
  :bind
  (:map ch/notes-map
        ("a" . org-agenda)
        ("s" . +default/org-notes-search)
        ("S" . +default/org-notes-headlines)
        ;; c bound to ch/org-clock-map
        ("C" . org-clock-cancel)
        ("f" . +default/find-in-notes)
        ("b" . +default/browse-notes)
        ("m" . org-tags-view)
        ("l" . org-store-link)
        ("o" . org-clock-goto)
        )
  (:map ch/org-insert-map
	("x"     . org-dynamic-block-insert-dblock)
	("d"     . org-insert-drawer)
	("@"     . org-cite-insert)
	("<"     . org-insert-structure-template)
	("|"     . org-table-create-or-convert-from-region)
	("l"     . org-insert-link)
	("M-l"   . org-insert-last-stored-link)
	("C-M-l" . org-insert-all-links))

  (:map ch/clock-map
	;; Timeclock
	("e"   . org-clock-modify-effort-estimate)
	("d"   . org-clock-display)
	("j"   . org-clock-goto)
	("C"   . org-clock-cancel)
	("l"   . org-clock-in-last)
	("i"   . org-clock-in)
	("o"   . org-clock-out)
	("r"   . org-resolve-clocks)
	;; Timer
	("-"    . org-timer-item)
	("."    . org-timer)
	(","    . org-timer-pause-or-continue)
	(";"    . org-timer-set-timer)
	("s"    . org-timer-start)
	("S"    . org-timer-stop))
  ;; (:map ch/sexp-map
  ;;       ("o" . org-emphasize))
  (:map org-mode-map
	("C-c C-,"       . nil)
	("C-c ,"         . org-priority)
	("C-c !"         . org-timestamp-inactive)
	("C-c C-!"       . org-timestamp)
	("C-c ^"         . org-sort)
	("C-c $"         . org-archive-subtree)
	("C-c :"         . org-toggle-fixed-width)
	("C-c ;"         . org-toggle-comment)
	("C-c C-t"       . org-todo)
	("C-c C-t"       . org-todo)
	("C-c C-q"       . org-set-tags-command)
	("C-c C-w"       . org-refile)
	("C-c C-h"       . org-set-property)
	("C-c C-M-w"     . org-refile-reverse)
	("C-c C-z"       . org-add-note)
	("C-c C-a"       . org-attach)
	("C-c C-e"       . org-export-dispatch)
	("C-c C-s"       . org-schedule)
	("C-c C-d"       . org-deadline)
	("C-c ."         . org-time-stamp)
	("C-c M-."       . org-time-stamp-inactive)
	("C-c C-x C-s"   . org-archive-subtree)
	("C-c C-x C-a"   . org-archive-subtree-default)
	("C-c C-x C-e"   . org-set-effort)
	("C-c C-x C-S-e" . org-encrypt-entry)
	("C-c C-x C-S-d" . org-decrypt-entry)
	("C-c C-x C-f"   . org-emphasize)
	("C-c C-x C-b"   . org-toggle-checkbox)
	("C-c C-x C-r"   . org-toggle-radio-button)
	("C-c C-x C-e"   . org-todo)
	("C-c C-x o"     . org-toggle-ordered-property)
	("C-c C-x a"     . org-toggle-archive-tag)
	("C-c C-x A"     . org-archive-to-archive-sibling)
	("C-c C-x p"     . org-set-property)
	("C-c C-x P"     . org-set-property-and-value)
	("C-c C-x b"     . org-tree-to-indirect-buffer)
	;; Heading Navigation
	("C-c C-b"       . org-backward-heading-same-level)
	("C-c C-f"       . org-forward-heading-same-level)
	("C-c C-n"       . org-next-visible-heading)
	("C-c C-p"       . org-previous-visible-heading)
	("C-c C-P"       . org-up-element)
	("C-c C-N"       . org-down-element)
	;; Link Navigation
	("C-c C-x C-n"   . org-next-link)
	("C-c C-x C-p"   . org-previous-link)
	;; Block Navigation
	("C-c M-p"       . org-previous-block)
	("C-c M-n"       . org-next-block))
  (:repeat-map org-mode-block-repeat-map
	       ("p"     . org-previous-block)
	       ("n"     . org-next-block))
  (:repeat-map org-mode-link-repeat-map
	       ("n" . org-next-link)
	       ("p" . org-previous-link))
  (:repeat-map org-mode-heading-repeat-map
	       ("TAB"       . org-fold-show-children)
	       ("S-TAB"     . org-shifttab)
	       ("<backtab>" . org-shifttab)
	       ("b"         . org-backward-heading-same-level)
	       ("f"         . org-forward-heading-same-level)
	       ("n"         . org-next-visible-heading)
	       ("p"         . org-previous-visible-heading)
	       ("P"         . org-up-element)
	       ("N"         . org-down-element))
  :init
  (setq org-directory (file-truename "~/org/"))
  (defvar ch/clock-map (make-sparse-keymap))
  (defvar ch/notes-map (make-sparse-keymap))
  (defvar ch/org-babel-map (make-sparse-keymap))
  (defvar ch/org-insert-map (make-sparse-keymap))
  (defvar org-agenda-directory (expand-file-name "agenda/" org-directory)
    "The Primary Directory in which to place agenda files")
  (defun ch/org-node-style-allowed-values (prop)
    (when (string-equal "STYLE" prop)
      (list "task"
            "habit"
            "note"
            "project"
            "article"
            "notebook")))
  (defun ch/org-property-get-or-set (property &optional value default)
    (interactive "*")
    (or (org--property-local-values property nil)
        (progn (org-set-property property
                                 (or value (org-read-property-value property nil default)))
               (org--property-local-values property nil))))
  (defun ch/org-get-or-set-created ()
    (interactive "*")
    (ch/org-property-get-or-set "CREATED" (format-time-string (org-time-stamp-format t t))))

  (keymap-set mode-specific-map "n" (cons "Notes" ch/notes-map))
  (keymap-set ch/notes-map "c" (cons "Clock" ch/clock-map))

  :config
  (setq
   org-id-method 'ts
   org-archive-location (concat org-directory "./archive/%s_archive::")
   org-return-follows-link t
   org-insert-heading-respect-content nil
   org-catch-invisible-edits 'show-and-error
   org-src-preserve-indentation t
                                        ; Appearance things
   org-auto-align-tags t
   org-tags-column 0
   org-ellipsis "…"
   +fold-ellipsis "…"
   org-cycle-inline-images-display t
   org-startup-with-latex-preview nil
   org-startup-with-inline-images nil
   org-startup-indented t
   org-startup-folded t
   org-hide-emphasis-markers t
   org-pretty-entities t
   org-pretty-entities-include-sub-superscripts nil)
  (add-to-list 'org-property-allowed-value-functions #'ch/org-node-style-allowed-values)
  (keymap-set org-mode-map "C-c C-S-i" ch/org-insert-map)
  (keymap-set org-mode-map "C-c C-v" ch/org-babel-map)
  ;; TODO Setting up blocks to match the background
  ;; (set-face-background 'org-block (face-background 'default))
  ;; (set-face-background 'org-block-begin-line (face-background 'default))
  ;; (set-face-background 'org-block-end-line (face-background 'default))
  (setq org-todo-keyword-faces
	'(("[-]" . +org-todo-active) ("NEXT" . +org-todo-active)
	  ("[?]" . +org-todo-onhold) ("HOLD" . +org-todo-onhold)
	  ("KILL" . +org-todo-cancel))
	org-refile-use-outline-path 'file
	org-outline-path-complete-in-steps nil
	org-refile-targets
	'((nil . (:maxlevel . 3))
	  (org-agenda-files . (:maxlevel . 3)))
	org-todo-keywords '((sequence "TODO(t)" "NEXT(n!/!)" "HOLD(h!/!)" "|" "DONE(d!)" "KILL(k!)")
			    (sequence "DRAFT(D)" "PENDING REVIEW(P!/!)" "|" "REVIEWED(R!/!)"))
	org-crypt-tag-matcher "CRYPT"
	;; Change the priorities to numbers
	org-priority-highest ?A
	org-priority-default ?C
	org-priority-lowest  ?E
	;; ascii values for 1-5
	org-priority-faces '((?A . error) (?B . warning) (?C . success) (?D . (:foreground "white" :weight "bold")) (?E . shadow))
	;; Log for everything and log it into a drawer
	org-log-refile 'time
	org-log-done 'time
	org-log-reschedule 'time
	org-log-redeadline 'time
	org-log-done-with-time t
	org-log-note-clock-out nil
	org-log-into-drawer t
	org-agenda-files (directory-files-recursively org-agenda-directory "\\.org$")
	org-agenda-window-setup 'current-window
	org-agenda-skip-unavailable-files t
	org-agenda-inhibit-startup t)

  (keymap-set mode-specific-map "\\" #'org-agenda)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-show-habits-only-for-today t)
  (after! 'catppuccin-theme
    (add-hook 'org-clock-in-hook #'org-save-all-org-buffers)
    (add-hook 'org-clock-out-hook #'org-save-all-org-buffers)
    (add-hook 'org-after-refile-insert-hook #'save-buffer))
  (add-hook! #'auto-save-hook #'org-save-all-org-buffers)
  (add-hook! 'org-mode-hook #'mixed-pitch-mode)
  (add-hook! 'org-mode-hook #'solaire-mode)
  (setq mixed-pitch-variable-pitch-cursor nil)
  <<modules-org-agenda>>
  )
#+end_src

#+RESULTS:

Enable word count in modes listed in ~doom-modeline-continuous-word-count-modes~

#+begin_src emacs-lisp
(setq doom-modeline-enable-word-count 't)
#+end_src

Make sure certain org faces use the fixed-pitch face when ~variable-pitch-mode~ is on
#+begin_src emacs-lisp
(require 'org-faces)
(set-face-attribute 'org-ellipsis nil :inherit 'default :box nil)
(set-face-attribute 'org-block nil :foreground 'unspecified :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

(when (display-graphic-p)
  (require 'all-the-icons))
#+end_src
****** Agenda
This is where configuration of general more task management and quick note
taking things takes place.

#+begin_src emacs-lisp :tangle no :noweb-ref modules-org-agenda
(setq org-todo-keyword-faces
      '(("[-]" . +org-todo-active) ("NEXT" . +org-todo-active)
        ("[?]" . +org-todo-onhold) ("HOLD" . +org-todo-onhold)
        ("KILL" . +org-todo-cancel))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-agenda-start-day nil
      org-refile-targets
     '((nil . (:maxlevel . 3))
       (org-agenda-files . (:maxlevel . 3)))
      org-todo-keywords '((sequence "TODO(t)" "NEXT(n!/!)" "HOLD(h!/!)" "|" "DONE(d!)" "KILL(k!)")
                          (sequence "DRAFT(D)" "PENDING REVIEW(P!/!)" "|" "REVIEWED(R!/!)"))
      org-crypt-tag-matcher "CRYPT"
      ;; Change the priorities to numbers
      org-priority-highest ?A
      org-priority-default ?C
      org-priority-lowest  ?E
      ;; ascii values for 1-5
      org-priority-faces '((?A . error) (?B . warning) (?C . success) (?D . (:foreground "white" :weight "bold")) (?E . shadow))
      ;; Log for everything and log it into a drawer
      org-log-refile 'time
      org-log-done 'time
      org-log-reschedule 'time
      org-log-redeadline 'time
      org-log-done-with-time t
      org-log-note-clock-out nil
      org-log-into-drawer t
      org-agenda-files (directory-files-recursively org-agenda-directory "\\.org$")
      org-agenda-window-setup 'current-window
      org-agenda-skip-unavailable-files t
      org-agenda-inhibit-startup t)

(keymap-set mode-specific-map "\\" #'org-agenda)
(add-to-list 'org-modules 'org-habit)
(setq org-habit-show-habits-only-for-today t)
(add-hook 'org-clock-in-hook #'org-save-all-org-buffers)
(add-hook 'org-clock-out-hook #'org-save-all-org-buffers)
(add-hook 'org-after-refile-insert-hook #'save-buffer)
#+end_src

When using ~org-pomodoro~ I prefer to take my breaks manually rather than simply
having the timer start, to give me a chance to finish things up.
#+begin_src emacs-lisp
(when (modulep! :lang org +pomodoro) (setq org-pomodoro-manual-break 't))
#+end_src

****** Capture
#+begin_src emacs-lisp
(use-package! org-capture
  :after org
  :bind (("C-c RET" . #'org-capture))
  :init


  (cl-defun my/org-capture-template-builder (&optional &key (keyword "") (tags "") (props ":STYLE: note") (priority (concat "[#" (string org-default-priority) "]")) (title "%?") (body "%i"))
    "The base template used by task templates"
    (format "* %s %s %s %s\n:PROPERTIES:\n:CREATED: %%U\n%s\n:END:\n%s\n" keyword priority title tags props body))

  (defun my/org-capture-template-note (&optional tags)
    "The base template used by note templates"
    (if tags
	    (my/org-capture-template-builder :tags tags)
      (my/org-capture-template-builder)))

  (defun my/org-capture-template-task (&optional tags)
    "The base template used by task templates"
    (if tags
	    (my/org-capture-template-builder :keyword "TODO" :tags tags :props ":STYLE: task")
      (my/org-capture-template-builder :keyword "TODO" :props ":STYLE: task"))))
#+end_src
***** Org-Gcal
#+begin_src emacs-lisp
(use-package! org-gcal
  :defer t
  :commands
  (org-gcal-sync
   org-gcal-fetch)
  :init
  (require 'plstore)
  (setq plstore-cache-passphrase-for-symmetric-encryption t)
  (add-to-list 'plstore-encrypt-to "AAAAGnNrLXNzaC1lZDI1NTE5QG9wZW5zc2guY29tAAAAICQ0pYmmeSLs0KflNWQr27XKsqx1GOedg0fpbvaVTPWGAAAABHNzaDo=")
  (setq org-gcal-fetch-file-alist (list
          (cons "carson03henrich@gmail.com"
                (expand-file-name "calendar/personal-cal.org" org-agenda-directory))
          (cons "o3cg75qglvtlkh0f6g3rcavj0802ljh0@import.calendar.google.com"
                (expand-file-name "calendar/classes-cal.org" org-agenda-directory))
          (cons "aa1a922f916e30885bb3bc3bbf777f1469be43c56d67a58835e417039bb059c1@group.calendar.google.com"
                (expand-file-name "calendar/school-cal.org" org-agenda-directory))
          (cons "52438d4c8ae0d9b84cd573a52506f42ed3470d5d80ba9cb924875eb11b695ffa@group.calendar.google.com"
                (expand-file-name "calendar/work-cal.org" org-agenda-directory))
          (cons "da6890e5b8c2af04ab7f95f0efc7b86401f9b3a24ca41852e2d786c2e432973e@group.calendar.google.com"
                (expand-file-name "calendar/awesomest-cal.org" org-agenda-directory))
          (cons "webcal://outlook.office365.com/owa/calendar/11387a547a7a4fb4ad5766b9918022b9@wwu.edu/df9706f6381940b6b9423fcb4ab56a1c5925903461175895289/S-1-8-1756129075-1537951449-1309253302-351361405/reachcalendar.ics"
                (expand-file-name "calendar/wwu-cal.org" org-agenda-directory))))
  (after! org
    (mapcar (apply-partially #'add-to-list 'org-agenda-files) (mapcar #'cdr org-gcal-fetch-file-alist)))
  :config
  (require 'pass)
  (setq
   org-gcal-client-id     (+pass-get-user "org-gcal-client")
   org-gcal-client-secret (+pass-get-secret "org-gcal-client"))
  (org-gcal-reload-client-id-secret))
#+end_src

***** Org-Babel
#+begin_src emacs-lisp
(use-package! ob
  :after org
  :bind
  (:map org-src-mode-map
        ("C-c C-c" . #'org-edit-src-exit))
  (:map ch/org-babel-map
        ("C-M-h" . org-babel-mark-block)
        ("C-a"   . org-babel-sha1-hash)
        ("C-b"   . org-babel-execute-buffer)
        ("C-c"   . org-babel-check-src-block)
        ("C-d"   . org-babel-demarcate-block)
        ("C-e"   . org-babel-execute-maybe)
        ("C-f"   . org-babel-tangle-file)
        ("C-j"   . org-babel-insert-header-arg)
        ("C-l"   . org-babel-load-in-session)
        ("C-n"   . org-babel-next-src-block)
        ("C-o"   . org-babel-open-src-block-result)
        ("C-p"   . org-babel-previous-src-block)
        ("C-r"   . org-babel-goto-named-result)
        ("C-s"   . org-babel-execute-subtree)
        ("C-t"   . org-babel-tangle)
        ("C-u"   . org-babel-goto-src-block-head)
        ("C-v"   . org-babel-expand-src-block)
        ("C-x"   . org-babel-do-key-sequence-in-edit-buffer)
        ("C-z"   . org-babel-switch-to-session)
        ("I"     . org-babel-view-src-block-info)
        ("TAB"   . org-babel-view-src-block-info)
        ("a"     . org-babel-sha1-hash)
        ("b"     . org-babel-execute-buffer)
        ("c"     . org-babel-check-src-block)
        ("d"     . org-babel-demarcate-block)
        ("e"     . org-babel-execute-maybe)
        ("f"     . org-babel-tangle-file)
        ("g"     . org-babel-goto-named-src-block)
        ("h"     . org-babel-describe-bindings)
        ("i"     . org-babel-lob-ingest)
        ("j"     . org-babel-insert-header-arg)
        ("k"     . org-babel-remove-result-one-or-many)
        ("l"     . org-babel-load-in-session)
        ("n"     . org-babel-next-src-block)
        ("p"     . org-babel-previous-src-block)
        ("o"     . org-babel-open-src-block-result)
        ("r"     . org-babel-goto-named-result)
        ("s"     . org-babel-execute-subtree)
        ("t"     . org-babel-tangle)
        ("u"     . org-babel-goto-src-block-head)
        ("v"     . org-babel-expand-src-block)
        ("x"     . org-babel-do-key-sequence-in-edit-buffer)
        ("z"     . org-babel-switch-to-session-with-code))
  (:repeat-map org-mode-babel-block-repeat-map
               ("n" . org-babel-next-src-block)
               ("p" . org-babel-previous-src-block))
  :config
  (setq org-babel-default-header-args
   '((:session . "none")
     (:results . "replace output")
     (:exports . "code")
     (:cache . "no")
     (:noweb . "yes")
     (:hlines . "no")
     (:tangle . "no")))

  (setq org-confirm-babel-evaluate nil) ;; Don't ask when executing a code block

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t))))
#+end_src

***** Calfw-ical
#+begin_src emacs-lisp :tangle no
(use-package! calfw-ical
  :config
  (defun ch/calendar/open-calendar ()
  "TODO"
  (interactive)
  (require 'pass)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source (face-foreground 'default))  ; orgmode source
    (cfw:ical-create-source "Personal"                   (+pass-get-secret "gcal-personal")   "Magenta")
    (cfw:ical-create-source "Classes"                    (+pass-get-secret "gcal-classes")    "Cyan")
    (cfw:ical-create-source "The Awesomest Calendar"     (+pass-get-secret "gcal-awesome")    "Purple")
    (cfw:ical-create-source "Work"                       (+pass-get-secret "gcal-work")       "Green")
    (cfw:ical-create-source "Assignments"                (+pass-get-secret "cal-assignments") "Blue")
;;    (cfw:ical-create-source "WWU"                        (+pass-get-secret "ocal-wwu")        "Orange")
    )))

  (setq +calendar-open-function #'ch/calendar/open-calendar))
#+end_src

***** OB-Mermaid
Very useful code blocks for when all you need is a simple diagram in some notes.
#+begin_src emacs-lisp
  (use-package! ob-mermaid
    :ensure t
    :after ob
    :config
    (add-to-list 'org-babel-load-languages '(mermaid . t)))
#+end_src

***** Org-Super-Agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :after org
  :config
  (setq org-agenda-category-icon-alist
        `(("inbox" ,(list (all-the-icons-faicon "inbox" :height 1.0)) nil nil :ascent center)
          ("Diary" ,(list (all-the-icons-faicon "book" :height 1.0)) nil nil :ascent center)
          ("finances" ,(list (all-the-icons-faicon "usd" :height 1.0)) nil nil :ascent center)
          ("calendar" ,(list (all-the-icons-faicon "calendar" :height 1.0)) nil nil :ascent center)
          ("school" ,(list (all-the-icons-faicon "graduation-cap" :height 1.0)) nil nil :ascent center)
          ("personal" ,(list (all-the-icons-faicon "user" :height 1.0)) nil nil :ascent center)
          ("trans" ,(list (all-the-icons-faicon "transgender" :height 1.0)) nil nil :ascent center)
          ("homelab" ,(list (all-the-icons-faicon "server" :height 1.0)) nil nil :ascent center)
          ("emacs" ,(list (all-the-icons-faicon "file-code-o" :height 1.0)) nil nil :ascent center)
          ("org" ,(list (all-the-icons-faicon "file-text" :height 1.0)) nil nil :ascent center)
          ("work" ,(list (all-the-icons-faicon "briefcase" :height 1.0)) nil nil :ascent center)
          ("career" ,(list (all-the-icons-faicon "building-o" :height 1.0)) nil nil :ascent center)))

  (setq org-agenda-prefix-format '((agenda . "%-4i %?-12t%-12s")
                                   (todo . "%?-4i %?-12t%-12s")
                                   (tags . "%i")
                                   (search . "%i")))
  (setq org-agenda-custom-commands
        '(("a" "Agenda"
           ((agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-use-time-grid nil)
                        (org-agenda-include-diary t)
                        (org-deadline-warning-days 7)
                        (org-agenda-span 'day)
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :order 1)
                           (:auto-property "STYLE"
                            :order 3)
                           (:auto-outline-path t
                            :order 5)))))))
          ("t" "Tasks"
           ((alltodo "" ((org-super-agenda-groups
                          `((:discard (:ancestor-with-todo "TODO" :habit t :todo "DONE" :todo "KILL" :not (:property ("STYLE" "task"))))
                            (:name "Inbox"
                             :file-path "*inbox.org"
                             :order 1)
                            (:name "Past"
                             :scheduled past
                             :deadline past
                             :order 2)
                            (:name "Today and Upcoming"
                             :date today
                             :scheduled today
                             :deadline today
                             :scheduled (before ,(format-time-string (org-time-stamp-format) (time-add nil (* 60 60 24 7))))
                             :deadline (before ,(format-time-string (org-time-stamp-format) (time-add nil (* 60 60 24 7))))
                             :order 3)
                            (:name "Later"
                             :scheduled future
                             :deadline future
                             :order 100)
                            (:name "HOLD"
                             :todo "HOLD"
                             :order 99)
                            (:name "Undated"
                             :and (:date nil :deadline nil :scheduled nil)
                             :order 98)))))))))
  (setq org-super-agenda-header-map (make-sparse-keymap))

  (org-super-agenda-mode))
;;  ensure the keymaps aren't different for the group header lines
#+end_src

#+RESULTS:

***** Org-Noter
#+begin_src emacs-lisp
(use-package! org-noter
  :defer t
  :when (modulep! :my_lang org +noter)
  :init
  (map!
   :map org-mode-map
   :localleader
   :desc "Org noter"                   "N" #'org-noter
   :desc "Import Skeleton"             "S" #'org-noter-create-skeleton
   :desc "Goto Notes page"             ";" #'org-noter-sync-current-note
   :desc "Goto next notes page"        "j" #'org-noter-sync-prev-note
   :desc "Goto prev notes page"        "k" #'org-noter-sync-next-note
   :desc "Kill Noter"                  "K" #'org-noter-kill-session)
  (map!
   :when (modulep! :tools pdf)
   :map pdf-view-mode-map
   :localleader
   :desc "Noter"                       "n" #'org-noter
   :desc "Insert Note"                 "i" #'org-noter-insert-note
   :desc "Insert Skeleton"             "S" #'org-noter-create-skeleton
   :desc "Insert Precise Note"         "I" #'org-noter-insert-precise-note
   :desc "Kill Noter"                  "K" #'org-noter-kill-session
   :desc "Goto pages Notes"            ";" #'org-noter-sync-current-page-or-chapter
   :desc "Goto next page with notes"   "j" #'org-noter-sync-next-page-or-chapter
   :desc "Goto prev page with notes"   "k" #'org-noter-sync-prev-page-or-chapter)

  :config
  (setq org-noter-notes-search-path
      (mapcar (lambda (x) (expand-file-name x org-directory)) '("agenda" "notes" "pages")))
  (unless org-noter-notes-search-path
    (setq org-noter-notes-search-path (list org-directory)))
  (org-noter-enable-org-roam-integration)
  (org-noter-enable-update-renames))
#+end_src
***** Org-Modern
#+begin_src emacs-lisp
  (use-package! org-modern
    :after org
    :when (modulep! :my_lang org +pretty)
    :config
    (setq
     org-modern-hide-stars nil; adds extra indentation
     org-modern-table nil
     org-modern-list
     '((?- . "-")
       (?* . "•")
       (?+ . "‣"))
     org-modern-star 'replace
     org-modern-block-name '(" " . " ") ; or other chars; so top bracket is drawn promptly
     org-modern-priority
      '((?A . "")
	(?B . "")
	(?C . "")
	(?D . "")
	(?E . ""))
     org-modern-todo-faces
     '(("TODO" :background "tangerine" :foreground "white")
       ("NEXT" :background "maroon" :foreground "white")
       ("HOLD" :background "white" :foreground "orange")
       ("DONE" :background "black" :foreground "green")
       ("KILL" :background "black" :foreground "red")
       ("DRAFT" :background "tangerine" :foreground "white")
       ("PENDING REVIEW" :background "white" :foreground "orange")
       ("REVIEWED" :background "black" :foreground "green")))

     (add-hook! org-agenda-finalize-hook #'org-modern-agenda)
     (global-org-modern-mode +1))
#+end_src

#+RESULTS:

***** Org-Modern-Indent
#+begin_src emacs-lisp
(use-package! org-modern-indent
  :after org
  :when (modulep! :my_lang org +pretty)
  :config ; add late to hook
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src
***** Org-Roam
#+begin_src emacs-lisp
(use-package! org-roam
  :after org
  :when (modulep! :my_lang org +roam)
  :bind (("C-c RET" . org-roam-capture)
         (:map org-mode-map
               :prefix "H-l"
               :prefix-map ch/org-mode-roam-map
               ( "I" . ch/org-roam-create-node))
         (:map ch/notes-map
               ("f" . org-roam-node-find)
               ("F" . +default/find-in-notes)
               ("p" . ch/org-roam-find-project)
               ("n" . ch/org-roam-capture-note)
               ("t" . ch/org-roam-capture-task)))

  :init
  (defvar org-capture-project-dir nil)
  (defvar org-projects-directory (expand-file-name "projects/" org-agenda-directory))
  (defun ch/org-roam-create-node ()
    (interactive "*")
    (ch/org-get-or-set-created)
    (org-id-get-create)
    (ch/org-property-get-or-set "STYLE" nil "task"))
  (defun ch/org-permenant-starter (title style filetags category &optional body)
    (concat
     "#+title: "
     title
     "\n#+author: %(concat user-full-name)"
     "\n#+email: %(concat user-mail-address)"
     "\n#+created: %(format-time-string \"[%Y-%m-%d %H:%M]\")"
     "\n#+style: "
     style
     "\n#+filetags: "
     filetags
     "\n#+category: "
     category
     "\n\n"
     body))

  ;; Ensure that org-roam's everywhere completion only actually suggests completion for articles
  (defun org-roam--get-article-titles ()
    (mapcar #'car (org-roam-db-query [:select :distinct title :from nodes
                                      :where (like properties '"%STYLE%article%")
                                      :union
                                      :select alias :from aliases
                                      :inner :join nodes :on (= nodes:id aliases:node_id)
                                      :where (like nodes:properties '"%STYLE%article%" )])))

  (fset 'org-roam-complete-everywhere
        #'(lambda () (when (and org-roam-completion-everywhere
                                (thing-at-point 'word)
                                (not (org-in-src-block-p))
                                (not (save-match-data (org-in-regexp org-link-any-re))))
                       (let ((bounds (bounds-of-thing-at-point 'word)))
                         (list (car bounds) (cdr bounds)
                               (org-roam--get-article-titles)
                               :exit-function
                               (lambda (str _status)
                                 (delete-char (- (length str)))
                                 (insert "[[roam:" str "]]"))
                               ;; Proceed with the next completion function if the returned titles
                               ;; do not match. This allows the default Org capfs or custom capfs
                               ;; of lower priority to run.
                               :exclusive 'no)))))


  (defun ch/org-project-header (filetags)
    (ch/org-permenant-starter "Project - ${title}" "project" filetags "${slug}" "* Links\n* Tasks\n* Notes\n"))

  (defun ch/org-article-header (filetags)
    (ch/org-permenant-starter "Article - ${title}" "article" filetags "${slug}"))

  (defun ch/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (ch/org-roam-filter-by-tag-file-nodes "project"))
                       :templates `(("p" "project" entry ,(my/org-capture-template-task)
                                     :if-new (file+head+olp "%(setq org-capture-project-dir (read-directory-name \"path: \" org-projects-directory))/${slug}.org"
                                                            ,(ch/org-project-header ":project:${slug}:")
                                                            ("Tasks"))))))
  (defun ch/org-roam-capture-note ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)

    ;; Capture the new note, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (ch/org-roam-filter-by-tag-file-nodes "project"))
                       :templates `(("p" "project" entry ,(my/org-capture-template-note)
                                     :if-new (file+head+olp "%(read-directory-name \"path: \" org-projects-directory)/${slug}.org"
                                                            ,(ch/org-project-header ":project:${slug}:")
                                                            ("Notes"))))))


  (defun ch/org-roam-project-finalize-hook ()
    "Adds the captured project file to `org-agenda-files' if the
capture was not aborted."
    ;; Remove the hook since it was added temporarily
    (remove-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)

    ;; Add project file to the agenda list if the capture was confirmed
    ;; Also add to projectile known projects
    (unless org-note-abort
      (with-current-buffer (org-capture-get :buffer)
        (let ((dir (f-dirname buffer-file-name)))
          (f-touch (expand-file-name projectile-dirconfig-file))
          (projectile-add-known-project dir)
          (add-to-list 'org-agenda-files (buffer-file-name))))))

  (defun ch/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)
    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (ch/org-roam-filter-by-tag-file-nodes "project")
     nil
     :templates
     `("p" "Project" plain ""
       :target (file+head
                "%(read-directory-name \"path: \" org-projects-directory)/${slug}.org"
                ,(ch/org-project-header ":project:${slug}:"))
       :unnarrowed t)))
  ;; The buffer you put this code in must have lexical-binding set to t!
  ;; See the final configuration at the end for more details.

  (defun ch/org-roam-filter-by-tag-file-nodes (tag-name)
    (lambda (node)
      (and
       (eq 0 (org-roam-node-level node))
       (member tag-name (org-roam-node-tags node)))))

  (defun ch/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun ch/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (ch/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun ch/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (ch/org-roam-list-notes-by-tag "project")))

  :config
  (setq
   org-roam-db-update-on-save 't
   org-roam-directory (expand-file-name org-directory)
   org-roam-extract-new-file-path "article/{id}.org")
  (org-roam-db-autosync-mode)
  (ch/org-roam-refresh-agenda-list)
  (defun nom/org-roam-capture-create-id ()
    "Create id for captured note and add it to org-roam-capture-template."
    (when (not org-note-abort)
      (org-roam-capture--put :id (org-id-get-create))))
  (setq org-roam-capture-templates
        (list
         (list "a" "Article"
               'plain ""
               :target (list
                        'file+head
                        "articles/${slug}.org"
                        (ch/org-article-header ":article:${slug}:"))
               :unnarrowed t)))


  (add-hook 'org-capture-prepare-finalize-hook 'nom/org-roam-capture-create-id)
  (require 'org-roam-export))
#+end_src

#+RESULTS:

***** Org-Roam-UI
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :when (modulep! :my_lang org +roam-ui)
  :after org-roam ;; or :after org
  ;;  normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;  a hookable mode anymore, you're advised to pick something yourself
  ;;  if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :bind
  (:map ch/notes-map
        ("g" . #'org-roam-graph))
  :config
  (setq
   org-roam-ui-sync-theme t
   org-roam-ui-follow t
   org-roam-ui-update-on-save t
   org-roam-ui-open-on-start t))
#+end_src

#+RESULTS:

***** Websocket
#+begin_src emacs-lisp
(use-package! websocket
    :when (modulep! :my_lang org +roam-ui)
    :after org-roam)
#+end_src
***** Org-ql
#+begin_src emacs-lisp
(use-package! org-ql
  :defer t
  :when (modulep! :my_lang org +query)
  :init
  (map!
   :leader
   :prefix ("n" . "notes")
   (:prefix ("q" . "query")
            :desc "Views"               "v" #'org-ql-view
            :desc "Find"                "f" #'org-ql-find
            :desc "Query Entries"       "q" #'org-ql-search)))
#+end_src

***** Org-roam-ql
#+begin_src emacs-lisp
(use-package! org-roam-ql
  :after org-roam
  :when (modulep! :my_lang org +query)
  :bind
  (:map org-roam-ql-mode-map
        ("q" . #'org-roam-ql-buffer-dispatch))
  (:map ch/notes-map
        ("q" . #'org-roam-ql-search))
  :config
  (after! meow
    (add-to-list 'meow-mode-state-list '(org-roam-ql-mode . motion))))
#+end_src

***** Org-roam-ql-ql
#+begin_src emacs-lisp
(use-package! org-roam-ql-ql
  :when (modulep! :my_lang org +query)
  :defer t)
#+end_src
***** Org-present
#+begin_src emacs-lisp
(use-package! org-present
              :defer t
              :when (modulep! :my_lang org +present)
              :init
              (map!
               :map org-mode-map
               :i "SPC" 'nil
               :n "J" 'nil
               :niv "s-[" #'my/org-present-prev
               :niv "s-]" #'my/org-present-next)
              :config
              ;; Configure fill width

              (defun my/org-present-next (&optional ARG)
                (interactive)
                (unless ARG (setq ARG 1))
                (my/org-present-change-heading ARG))

              (defun my/org-present-prev (&optional ARG)
                (interactive)
                (if ARG (setq ARG (- ARG))(setq ARG -1))
                (my/org-present-change-heading ARG))

              (defun my/org-present-change-heading (ARG)
                (doom/widen-indirectly-narrowed-buffer)
                (org-next-visible-heading ARG)
                (org-narrow-to-subtree)
                (my/org-present-prepare-slide))

              (defun my/org-present-toggle-cursor ()
                (interactive)
                (if cursor-hidden (progn (org-present-show-cursor)
                                         (hl-line-mode 1)
                                         (setq cursor-hidden 'nil)
                                         (message "Cursor Shown"))
                  (progn (org-present-hide-cursor)
                         (hl-line-mode 0)
                         (setq cursor-hidden 't)
                         (message "Cursor Hidden"))))

              (defun my/org-present-start ()
                (display-line-numbers-mode 0)
                (hide-mode-line-mode 1)
                (mixed-pitch-mode 1)
                (flyspell-mode 0)
                (flycheck-mode 0)
                (writegood-mode 0)
                ;; Center the presentation and wrap lines
                (visual-fill-column-mode 1)
                (visual-line-mode 1)
                (org-present-show-cursor)
                ;; Set a blank header line string to create blank space at the top
                (setq header-line-format "")
                ;; Tweak font sizes
                (setq-local face-remapping-alist '((default (:height 1.3) variable-pitch)
                                                   (header-line (:height 3.7) variable-pitch)
                                                   (org-link (:height 1.3) org-drawer)
                                                   (org-document-title (:height 1.6) org-document-title)
                                                   (org-code (:height 1.25) org-code)
                                                   (org-table fixed-pitch shadow)
                                                   (org-verbatim (:height 1.3) org-verbatim)
                                                   (org-block (:height 1.1) org-block)
                                                   (org-block-begin-line (:height 0.7) org-block))))

              (defun my/org-present-end ()
                (display-line-numbers-mode 1)
                (mixed-pitch-mode 1)
                (hide-mode-line-mode 0)
                (flyspell-mode 1)
                (flycheck-mode 1)
                (writegood-mode 1)
                ;; Stop centering the document
                (visual-fill-column-mode 0)
                (visual-line-mode 0)
                (setq header-line-format 'nil)
                ;; Reset font customizations
                (setq-local face-remapping-alist '((default default default))))
              ;; Clear the header line format by setting to `nil'

              (defun my/org-present-prepare-slide ()
                ;; Show only top-level headlines
                (org-overview)

                ;; Unfold the current entry
                (org-show-entry)

                ;; Show only direct subheadings of the slide but don't expand them
                (org-show-children))

              (defun my/org-present-navigate (buffer-name heading)
                (my/org-present-prepare-slide))

              ;; Register hooks with org-present
              (add-hook 'org-present-after-navigate-functions 'my/org-present-navigate)
              (add-hook 'org-present-mode-hook 'my/org-present-start)
              (add-hook 'org-present-mode-quit-hook 'my/org-present-end))
#+end_src

***** Ox-hugo
#+begin_src emacs-lisp :noweb yes
(use-package! ox-hugo
              :when (modulep! :my_lang org +hugo)
              :after ox)
#+end_src

***** Nov
#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :bind
  (:map nov-mode-map
        ("h" . #'meow-left)
        ("j" . #'meow-next)
        ("k" . #'meow-prev)
        ("l" . #'meow-right)
        ("b" . #'nov-history-back)
        ("f" . #'nov-history-forward)
        ("]" . #'nov-scroll-up)
        ("[" . #'nov-scroll-down)
        ("}" . #'nov-next-document)
        ("{" . #'nov-previous-document))
  :config
  (setq nov-text-width t)
  (defun ch/nov-font-setup ()
    (setq-local visual-fill-column-width 130
                visual-fill-column-center-text t)

    (face-remap-add-relative 'default :height 1.2))

  (add-hook 'nov-mode-hook 'ch/nov-font-setup)
  (add-hook 'nov-mode-hook 'visual-line-mode)
  (add-hook 'nov-mode-hook 'visual-fill-column-mode))
#+end_src

#+RESULTS:

*** TODO SQL
#+begin_src emacs-lisp :tangle packages.el
(package! sql-indent)
#+end_src

#+begin_src emacs-lisp :tangle config.el
(add-hook 'sql-mode-hook 'lsp)
#+end_src
*** TODO Kotlin
#+begin_src emacs-lisp :tangle config.el
(use-package! ob-kotlin
  :after ob
  :ensure t
  :when (and (modulep! :lang kotlin)(modulep! :my_lang org))
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((kotlin . t))))
#+end_src
** My_Tools
*** Mail
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/mail/packages.el :noweb yes
:END:

#+begin_src emacs-lisp
;;; -*- no-byte-compile: t -*-
;;(package! mu4e)
;;(package! org-msg)
#+end_src
**** Checks
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/mail/doctor.el :lexical t
:END:
Modules sanity checks run on ~doom doctor~
***** Doom Mail Module
#+begin_src emacs-lisp
(unless (modulep! :email mu4e)
  (warn! "Module my_tools/mu4e is expected to be run with Module email/mu4e, not doing so is undefined behavior"))
#+end_src
***** Mu Binary Dependency
#+begin_src emacs-lisp
(unless (executable-find "mu")
  (warn! "`mu` executable could not be found, Please install it and make sure it is on your PATH"))
#+end_src

***** Mbsync Binary Dependency
#+begin_src emacs-lisp
(unless (executable-find "mbsync")
  (warn! "`mbsync` executable could not be found, Please install it and make sure it is on your PATH"))
#+end_src
***** Msmtp Binary Dependency
#+begin_src emacs-lisp
(unless (executable-find "msmtp")
  (warn! "`msmtp` executable could not be found, Please install it and make sure it is on your PATH"))
#+end_src
**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/mail/config.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src
***** Mu4e
#+begin_src emacs-lisp
(use-package! mu4e
  :commands (mu4e-headers-mode
             mu4e-view-mode
             mu4e
             org-mu4e-open)
  :when (modulep! :my_tools mail)
  :defer t
  :bind (:map mu4e-main-mode-map
         ("J" . #'mu4e-search-maildir)
         ("I" . #'mu4e-update-index)
         :map mu4e-headers-mode-map
         ("J" . #'mu4e-search-maildir)
         ("U" . #'mu4e-update-mail-and-index)
         ("I" . #'mu4e-update-index)
         ("m" . #'mu4e-headers-mark-for-something)
         ("M" . #'mu4e-headers-mark-for-move)
         ("X" . #'mu4e-mark-resolve-deferred-marks)
         :map mu4e-view-mode-map
         ("J" . #'mu4e-search-maildir)
         ("U" . #'mu4e-update-mail-and-index)
         ("I" . #'mu4e-update-index)
         ("m" . #'mu4e-view-mark-for-something)
         ("M" . #'mu4e-view-mark-for-move)
         ("X" . #'mu4e-mark-resolve-deferred-marks))

  :init
  (defun ch/render-html-message ()
    (let ((dom (libxml-parse-html-region (point-min) (point-max))))
      (erase-buffer)
      (shr-insert-document dom)
      (goto-char (point-min))))
  (defvar ch/org-capture-email-tag "EMAIL"
    "Tag to be added to captures created from emails")

  :config
  (setq
   mu4e-context-policy 'pick-first
   mu4e-mu-binary (executable-find "mu")
   org-mu4e-link-query-in-headers-mode nil
   mu4e-maildir "~/.maildir"
   mu4e-notification-support t
   mu4e-get-mail-command (concat (executable-find "mbsync") " -a")
   mu4e-html2text-command 'ch/render-html-message
   mu4e-update-interval 300 ;; seconds
   mu4e-attachment-dir "~/Desktop"
   message-citation-line-format "%N @ %Y-%m-%d %H:%M :\n"
   mu4e-headers-visible-lines 20
   mu4e-change-filenames-when-moving 't
   mu4e-split-view 'horizontal
   mu4e-index-cleanup t
   mu4e-index-lazy-check t    ;; don't consider up-to-date dir
   mu4e-compose-context-policy 'ask ;; ask for context if no context matches
   mail-user-agent 'mu4e-user-agent
   message-mail-user-agent 'mu4e-user-agent
   mu4e-headers-fields
   '((:account-stripe . 1)
     (:human-date . 12)
     (:category . 15)
     (:from-or-to . 30)
     (:flags . 10)
     (:subject)
     )
   mu4e-use-fancy-chars t)
  (setq mu4e-headers-new-mark `("N"      . ,(all-the-icons-material "inbox")))
  (setq mu4e-headers-draft-mark `("D"    . ,(all-the-icons-material "create")))
  (setq mu4e-headers-unread-mark `("u"   . ,(all-the-icons-material "markunread")))
  (setq mu4e-headers-seen-mark `("S"     . ,(all-the-icons-material "drafts")))
  (setq mu4e-headers-replied-mark `("R"  . ,(all-the-icons-material "reply")))
  (setq mu4e-headers-passed-mark `("P"   . ,(all-the-icons-material "forward")))
  (setq mu4e-headers-attach-mark `("a"   . ,(all-the-icons-material "attachment")))
  (setq mu4e-headers-list-mark `("L"     . ,(all-the-icons-material "list")))
  (setq mu4e-headers-trashed-mark `("T"  . ,(all-the-icons-material "delete")))
  (setq mu4e-headers-calendar-mark `("c" . ,(all-the-icons-material "date_range")))
  (setq mu4e-headers-personal-mark `("p" . ,(all-the-icons-material "person")))
  (setq mu4e-headers-signed-mark `("s"   . ,(all-the-icons-material "verified_user")))
  (setq mu4e-headers-encrypted-mark `("x". ,(all-the-icons-material "vpn_key")))
  (setq mu4e-modeline-all-read `("R:"    . ,(all-the-icons-material "drafts")))
  (setq mu4e-modeline-all-clear `("C:"   . ,(all-the-icons-material "inbox")))
  (setq mu4e-modeline-new-items `("N:"   . ,(all-the-icons-material "markunread_mailbox")))
  (setq mu4e-modeline-unread-items `("U:". ,(all-the-icons-material "markunread")))

  (add-to-list 'mu4e-header-info-custom
               '(:category .
                 (:name "Category"
                  :shortname "Category"
                  :help "What is the last directory in the maildir path"
                  :function
                  (lambda (msg)
                    (let ((maildir (replace-regexp-in-string
                                    "\\`/?\\([^/]+\\)/.*\\'" "\\1"
                                    (mu4e-message-field msg :maildir)))
                          (category (f-base (mu4e-message-field msg :maildir))))
                      (+mu4e-colorize-str
                       category
                       '+mu4e-header--maildir-colors
                       maildir))))))

  (after! meow
    (add-to-list 'meow-mode-state-list '(mu4e-view-mode . motion)))

  <<mu4e-capture>>
  <<mu4e-accounts>>
  <<mu4e-sending>>
  <<mu4e-hyperspace>>
  (with-eval-after-load "mm-decode"
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text/richtext")))
#+end_src

****** Accounts
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb yes :results silent :lexical yes :comments noweb :noweb-ref mu4e-accounts
:END:

******* Address List

#+begin_src emacs-lisp
(setq mu4e-user-mail-address-list
      '("carson03henrich@gmail.com"
	"carson3henrich@gmail.com"
	"henricc5@wwu.edu"))
#+end_src

******* Bookmarks
#+begin_src emacs-lisp
(defvar ch/mu4e-inbox-folder nil)
(defvar ch/mu4e-important-folder nil)

(defun ch/set-mu4e-maildirs ()
  (setq mu4e-maildir-shortcuts
        (list (list :name "Inbox" :maildir ch/mu4e-inbox-folder :key ?i)
              (list :name "Important" :maildir ch/mu4e-important-folder :key ?j)
              (list :name "Sent" :maildir mu4e-sent-folder :key ?s)
              (list :name "Drafts" :maildir mu4e-drafts-folder :key ?d)
              (list :name "Archive" :maildir mu4e-refile-folder :key ?a))))

(add-hook 'mu4e-context-changed-hook #'ch/set-mu4e-maildirs)

(setq mu4e-bookmarks
      '((:name "Unread messages"           :query "flag:unread" :key ?u   :favorite t)
        (:name "Today's messages"          :query "date:today..now"                  :key ?t)
        (:name "Last 7 days"               :query "date:7d..now"                     :key ?w)
        (:name "Inboxes"                   :query "maildir:/Inbox$/"                 :key ?i)
        (:name "Flagged messages"          :query "flag:flagged"                     :key ?f)))
#+end_src
******* Contexts
#+begin_src emacs-lisp
(setq mu4e-contexts
      (list
       (make-mu4e-context
	:name "1_gmail"
	:match-func
	(lambda (msg)
	  (when msg (string-prefix-p "/gmail1" (mu4e-message-field msg :maildir))))
	:vars '((user-mail-address . "carson03henrich@gmail.com")
		(user-full-name . "Carson Henrich")
		(smtpmail-smtp-user "carson03henrich@gmail.com")
        (ch/mu4e-inbox-folder . "/gmail1/Inbox")
        (ch/mu4e-important-folder . "/gmail1/Important")
		(mu4e-drafts-folder . "/gmail1/Drafts")
		(mu4e-refile-folder . "/gmail1/Archive")
		(mu4e-sent-folder . "/gmail1/Sent")
		(mu4e-trash-folder . "/gmail1/Trash")))
       (make-mu4e-context
	:name "2_gmail"
	:match-func
	(lambda (msg)
	  (when msg (string-prefix-p "/gmail2" (mu4e-message-field msg :maildir))))
	:vars '((user-mail-address . "carson3henrich@gmail.com")
		(user-full-name . "Carson Henrich")
		(smtpmail-smtp-user "carson3henrich@gmail.com")
        (ch/mu4e-inbox-folder . "/gmail2/Inbox")
        (ch/mu4e-important-folder . "/gmail2/Important")
		(mu4e-drafts-folder . "/gmail2/Drafts")
		(mu4e-refile-folder . "/gmail2/Archive")
		(mu4e-sent-folder . "/gmail2/Sent")
		(mu4e-trash-folder . "/gmail2/Trash")))
       (make-mu4e-context
	:name "western"
	:match-func (lambda (msg)
                      (when msg (string-prefix-p "/school" (mu4e-message-field msg :maildir))))
	:vars '((user-mail-address . "henricc5@wwu.edu")
		(user-full-name . "Carson Henrich")
		(smtpmail-smtp-user "henricc5@wwu.edu")
        (ch/mu4e-inbox-folder . "/school/Inbox")
        (ch/mu4e-important-folder . "/school/Important")
		(mu4e-drafts-folder . "/school/Drafts")
		(mu4e-refile-folder . "/school/Archive")
		(mu4e-sent-folder . "/school/Sent")
		(mu4e-trash-folder . "/school/Trash")))))
#+end_src
****** Sending
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb yes :results silent :lexical yes :comments noweb :noweb-ref mu4e-accounts
:END:
#+begin_center
Hooks related to ~mu4e-compose-mode~ are set with a depth < 0 so that the will be
placed before the buffer is transitioned to ~OrgMsg~ otherwise they do not run
#+end_center

#+begin_src emacs-lisp
;; gpg encryptiom & decryption:
(require 'epa-file)
(epa-file-enable)
(setq epa-pinentry-mode 'loopback)

;; don't keep message compose buffers around after sending:
(setq message-kill-buffer-on-exit t)
;; send function:
(setq send-mail-function 'sendmail-send-it
      message-send-mail-function 'sendmail-send-it
      message-sendmail-extra-arguments '("--read-envelope-from")
      message-sendmail-f-is-evil t)

;; send program:
(setq sendmail-program (executable-find "msmtp"))

;; select the right sender email from the context.
(setq mail-specify-envelope-from t
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header)

;; mu4e cc & bcc
;; this is custom as well
(defun timu/add-cc-and-bcc ()
  "My Function to automatically add Cc & Bcc: headers.
    This is in the mu4e compose mode."
  (save-excursion (message-add-header "Cc:\n"))
  (save-excursion (message-add-header "Bcc:\n")))

(add-hook 'mu4e-compose-mode-hook 'timu/add-cc-and-bcc -10)
(add-hook 'mu4e-compose-mode-hook (lambda () (flyspell-mode t)) -10)
(add-hook 'mu4e-compose-mode-hook (lambda () (auto-fill-mode t)) -10)
;; TODO (add-hook 'mu4e-compose-mode-hook (lambda () (writegood-mode t)) -10)

(defun my/mu4e-set-reply-sender ()
  "Select which of your particpating addresses in the previous message, that should
  be the sender of this reply."
  (save-excursion
    (when mu4e-compose-parent-message ;; Ensures this is a reply
      (let* ((participants (-filter
                         #'(lambda (rcv) (mu4e-personal-address-p (plist-get rcv :email)))
                         (append
                          (mu4e-message-field mu4e-compose-parent-message :to)
                          (mu4e-message-field mu4e-compose-parent-message :cc)
                          (mu4e-message-field mu4e-compose-parent-message :bcc)
                          (mu4e-message-field mu4e-compose-parent-message :from)))) ;; Allows for replying to yourself
             (participant (if (cdr participants)
                           (widget-choose "Select an Email to Reply from:"
                                          (mapcar (lambda (p) (cons (plist-get p :email) p)) participants))
                         (car participants)))
             (email (plist-get participant :email))
             (name (plist-get participant :name))
             (from-header (concat "From: " (message-make-from name email))))

        (when participant
          (message-remove-header "From")
          (message-add-header from-header))))))

(add-hook 'mu4e-compose-mode-hook 'my/mu4e-set-reply-sender -10)
#+end_src
****** Capture Emails to Agenda
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb yes :results silent :lexical yes :comments noweb :noweb-ref mu4e-capture
:END:

Function for correctly storing a link to an email courtesy of [[https://stackoverflow.com/questions/17254967/using-org-capture-templates-with-mu4e][emacs - Using org-capture-templates with mu4e - Stack Overflow]]

#+begin_src emacs-lisp
(after! org
  (defun org-mu4e-store-link ()
    "Store a link to a mu4e query or message."
    (cond
     ;; storing links to queries
     ((eq major-mode 'mu4e-headers-mode)
      (let* ((query (mu4e-last-query))
	         desc link)
	    (org-store-link-props :type "mu4e" :query query)
	    (setq
	     desc (concat "mu4e:query:" query)
	     link desc)
	    (org-add-link-props :link link :description desc)
	    link))
     ;; storing links to messages
     ((eq major-mode 'mu4e-view-mode)
      (let* ((msg  (mu4e-message-at-point))
	         (msgid   (or (plist-get msg :message-id) "<none>"))
	         (from (car (car (mu4e-message-field msg :from))))
	         (to (car (car (mu4e-message-field msg :to))))
	         (subject (mu4e-message-field msg :subject))
	         link)
	    (setq link (concat "mu4e:msgid:" msgid))
	    (org-store-link-props :type "mu4e" :link link
			                  :message-id msgid)
	    (setq link (concat "mu4e:msgid:" msgid))
	    (org-store-link-props
	     :type "mu4e" :from from :to to :subject subject
	     :message-id msgid)

	    (org-add-link-props :link link
			                :description (funcall org-mu4e-link-desc-func msg))
	    link))))

  (org-add-link-type "mu4e" 'org-mu4e-open)
  (add-hook 'org-store-link-functions 'org-mu4e-store-link))
#+end_src

#+begin_src emacs-lisp
 (after! org
   (defun my/org-capture-template-email (style)
     "The base template used by task templates"
     (my/org-capture-template-builder :keyword "TODO"
                                      :title "%a"
                                      :tags ":EMAIL:"
                                      :props (format ":FROM:  %%:from\n:TO:  %%:to\n:STYLE:  %s\n" style)))

   (defun ch/org-roam-capture-email-task ()
     (interactive)
     ;; Add the project file to the agenda after capture is finished
     (add-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)

     ;; Capture the new task, creating the project file if necessary
     (org-roam-capture- :node (org-roam-node-read
                               nil
                               (ch/org-roam-filter-by-tag-file-nodes "project"))
                        :templates `(("t" "Email Task" entry (function ,(lambda () (my/org-capture-template-email "task")))
                                     :if-new (file+head+olp "%(setq org-capture-project-dir (read-directory-name \"path: \" org-projects-directory))/${slug}.org"
                                                            ,(ch/org-project-header ":project:${slug}:")
                                                            ("Tasks"))))))
   (defun ch/org-roam-capture-email-note ()
     (interactive)
     ;; Add the project file to the agenda after capture is finished
     (add-hook 'org-capture-after-finalize-hook #'ch/org-roam-project-finalize-hook)

     ;; Capture the new task, creating the project file if necessary
     (org-roam-capture- :node (org-roam-node-read
                               nil
                               (ch/org-roam-filter-by-tag-file-nodes "project"))
                        :templates `(("n" "Email Note" entry (function ,(lambda () (my/org-capture-template-email "note")))
                                     :if-new (file+head+olp "%(setq org-capture-project-dir (read-directory-name \"path: \" org-projects-directory))/${slug}.org"
                                                            ,(ch/org-project-header ":project:${slug}:")
                                                            ("Notes"))))))

  (keymap-set mu4e-headers-mode-map "z" #'ch/org-roam-capture-email-task)
  (keymap-set mu4e-headers-mode-map "Z" #'ch/org-roam-capture-email-note))


#+end_src
***** Hyperspace Query
#+begin_src emacs-lisp :tangle no :noweb-ref mu4e-hyperspace
(with-eval-after-load 'hyperspace
 (defun hyperspace--mu4e-context (query)
   "Return a mu4e context for QUERY.

     If the first word of QUERY matches the beginning of a mu4e
     context, return its name.  Otherwise, return NIL."
   (cl-loop with parts = (s-split-up-to "\\s-+" query 1)
            with possible-context = (car parts)
            with possible-query = (cadr parts)
            for context in mu4e-contexts
            for context-name = (mu4e-context-name context)
            if (s-starts-with? possible-context context-name)
            return (cons context-name possible-query)))

 (defun hyperspace-action->mu4e (&optional query)
   "Search mu4e with QUERY.

     If QUERY is unspecified, use the first bookmark in variable
     ‘mu4e-bookmarks’ and update mail and index."

   (mu4e-headers-search (or query (caar mu4e-bookmarks)))
   (unless query
     (mu4e-update-mail-and-index nil)))

 (defun hyperspace-action->mu4e-context (&optional query)
   "Look for a mu4e context in the first word of QUERY.

     A valid context is one which matches a left-anchored substring of
     all defined mu4e contexts.

     If found, switch to it, then call `hyperspace-action->mu4e' with
     the remainder of QUERY.  Otherwise, call with the entire QUERY,
     without switching the context."

   (thread-first
     (pcase (hyperspace--mu4e-context query)
       (`(context . query)
        (mu4e-context-switch nil context)
        query))
     (or query)
     (hyperspace-action->mu4e)))
 (ch/add-list-to-list 'hyperspace-actions '(("m4" . hyperspace-action->mu4e)
                                            ("m4c" . hyperspace-action->mu4e-context))))
#+end_src

***** Org-Msg
#+begin_src emacs-lisp
(use-package! org-msg
  :after mu4e
  :hook
  (mu4e-compose-mode . org-msg-post-setup)
  (mu4e-compose-pre  . org-msg-mode)
  :config
  (setq
   org-msg-greeting-fmt "\nHi%s,\n\n"
   org-msg-recipient-names 'nil
   org-msg-greeting-name-limit 3
   org-msg-convert-citation t
   org-msg-signature "Cheers,\n\n#+begin_signature\n--\n*Carson Henrich*\n#+end_signature\n"
   org-msg-default-alternatives '((new           . (text html))
                                  (reply-to-html . (text html))
                                  (reply-to-text . (text)))))
#+end_src

#+RESULTS:
*** TODO Magit
#+begin_src emacs-lisp :tangle config.el
(setq-default with-editor-emacsclient-executable "emacsclient")
(use-package! magit
  :config
  (keymap-set magit-mode-map "x" #'magit-discard))
#+end_src
*** TODO RSS
#+begin_src emacs-lisp :tangle config.el
(use-package! elfeed
:init
(defun ime-elfeed-podcast-tagger (entry)
   (when (elfeed-entry-enclosures entry)
     (elfeed-tag entry 'media)))
:config
 (add-hook 'elfeed-new-entry-hook #'ime-elfeed-podcast-tagger)
 (add-hook 'elfeed-show-mode-hook #'elfeed-update)

 (setq elfeed-goodies/entry-pane-size 0.5)

 (define-keymap :keymap elfeed-show-mode-map
   "U" (cons "Update Feeds" #'elfeed-update))
 (define-keymap :keymap elfeed-search-mode-map
   "U" (cons "Update Feeds" #'elfeed-update))

 (after! org
   (elfeed-org)
   (setq rmh-elfeed-org-files (list (expand-file-name "elfeed.org" org-directory)))))
#+end_src

*** TODO AI
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/ai/packages.el :lexical nil
:END:
#+begin_src emacs-lisp
(package! gptel)
(package! ellama)
(when (modulep! :my_tools ai +copilot)
  (package! copilot :recipe (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))))
(when (modulep! :my_tools ai +whisper)
  (package! whisper :recipe (:host github :repo "natrys/whisper.el" :files ("*.el"))))
#+end_src
**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/ai/config.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src
***** Keymaps

#+begin_src emacs-lisp
(defvar ch/ai-keymap (make-sparse-keymap))
(keymap-set mode-specific-map "a" ch/ai-keymap)
#+end_src

#+RESULTS:

***** Copilot
#+begin_src emacs-lisp
;; accept completion from copilot and fallback to corfu
(use-package! copilot
  :when (modulep! :my_tools ai +copilot)
  :hook (prog-mode . copilot-mode)

  :bind (:map ch/ai-keymap
              ("TAB" . 'copilot-mode))
  (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src

***** Whisper
#+begin_src emacs-lisp
(use-package! whisper
  :when (modulep! :my_tools ai +whisper)
  :bind
  (:map ch/ai-keymap
        ("w" . whisper-run)
        ("W" . whisper-file))
  :init
  (defun rk/get-ffmpeg-device ()
    "Gets the list of devices available to ffmpeg.
The output of the ffmpeg command is pretty messy, e.g.
  [AVFoundation indev @ 0x7f867f004580] AVFoundation video devices:
  [AVFoundation indev @ 0x7f867f004580] [0] FaceTime HD Camera (Built-in)
  [AVFoundation indev @ 0x7f867f004580] AVFoundation audio devices:
  [AVFoundation indev @ 0x7f867f004580] [0] Cam Link 4K
  [AVFoundation indev @ 0x7f867f004580] [1] MacBook Pro Microphone
so we need to parse it to get the list of devices.
The return value contains two lists, one for video devices and one for audio devices.
Each list contains a list of cons cells, where the car is the device number and the cdr is the device name."
    (unless (string-equal system-type "darwin")
      (error "This function is currently only supported on macOS"))

    (let ((lines (string-split (shell-command-to-string "ffmpeg -list_devices true -f avfoundation -i dummy || true") "\n")))
      (cl-loop with at-video-devices = nil
               with at-audio-devices = nil
               with video-devices = nil
               with audio-devices = nil
               for line in lines
               when (string-match "AVFoundation video devices:" line)
               do (setq at-video-devices t
                        at-audio-devices nil)
               when (string-match "AVFoundation audio devices:" line)
               do (setq at-audio-devices t
                        at-video-devices nil)
               when (and at-video-devices
                         (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
               do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) video-devices)
               when (and at-audio-devices
                         (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
               do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) audio-devices)
               finally return (list (nreverse video-devices) (nreverse audio-devices)))))

 (defun rk/find-device-matching (string type)
   "Get the devices from `rk/get-ffmpeg-device' and look for a device
matching `STRING'. `TYPE' can be :video or :audio."
   (let* ((devices (rk/get-ffmpeg-device))
          (device-list (if (eq type :video)
                           (car devices)
                         (cadr devices))))
     (cl-loop for device in device-list
              when (string-match-p string (cdr device))
              return (car device))))

 (defcustom rk/default-audio-device nil
   "The default audio device to use for whisper.el and outher audio processes."
   :type 'string)

 (defun rk/select-default-audio-device (&optional device-name)
   "Interactively select an audio device to use for whisper.el and other audio processes.
If `DEVICE-NAME' is provided, it will be used instead of prompting the user."
   (interactive)
   (let* ((audio-devices (cadr (rk/get-ffmpeg-device)))
          (indexes (mapcar #'car audio-devices))
          (names (mapcar #'cdr audio-devices))
          (name (or device-name (completing-read "Select audio device: " names nil t))))
     (setq rk/default-audio-device (rk/find-device-matching name :audio))
     (when (boundp 'whisper--ffmpeg-input-device)
       (setq whisper--ffmpeg-input-device (format ":%s" rk/default-audio-device)))))

 :config
  (setq whisper-install-directory "/tmp/"
       whisper-model "base"
       whisper-language "en"
       whisper-translate nil
       whisper-use-threads (/ (num-processors) 2)))
#+end_src
***** GPTel
#+begin_src emacs-lisp
(use-package! gptel
  :bind (:map ch/ai-keymap
              ("g" . #'gptel)
              ("G" . #'gptel-system-prompt))
  :config
  ;; :key can be a function that returns the API key.
  (setq gptel-prompt-prefix-alist
        '((markdown-mode . "## ")
         (org-mode . "** ")
         (text-mode . "## ")))
  (setq gptel-response-prefix-alist
        '((markdown-mode . "### AI RESPONSE\n")
         (org-mode . "*** AI RESPONSE\n")
         (text-mode . "### AI RESPONSE")))
  (set-popup-rule!  '(and (lambda (&rest args) (symbol-value 'gptel-mode)))
    :side 'right
    :width 90
    :select t)
  (gptel-make-ollama "Ollama"
    :host "localhost:11434"
    :stream t
    :models '("mistral:latest"
              "zephyr:latest"
              "llama3.1:latest")))

#+end_src

#+RESULTS:

**** Checks
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/ai/doctor.el
:END:
#+begin_src emacs-lisp
(unless (executable-find "ollama")
  (warn! "`ollama` executable could not be found, Please install it and make sure it is on your PATH"))
#+end_src
*** TODO COMMENT Grammarly
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/grammarly/packages.el :lexical nil
:END:

#+begin_src emacs-lisp
;; (package! flycheck-grammarly)
(package! eglot-grammarly
  :recipe (:host github :repo "emacs-grammarly/eglot-grammarly"))
#+end_src
**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/grammarly/config.el :noweb yes
:END:
#+begin_src emacs-lisp
;; (use-package! flycheck-grammarly
;;   :init
;;   (after! flycheck
;;     (flycheck-grammarly-setup))
;;   :config
;;   (setq flycheck-grammarly-check-time 0.8))
(use-package! eglot-grammarly
  ;; :hook (text-mode . )
  :init
  (defun ch/grammarly-eglot-setup ()
    (interactive)
    (require 'eglot-grammarly)
    (call-interactively #'eglot)))
#+end_src
**** Checks
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_tools/grammarly/doctor.el
:END:
#+begin_src emacs-lisp
(unless (executable-find "grammarly-languageserver")
  (warn! "`grammarly-languageserver` executable could not be found, Please install it and make sure it is on your PATH"))
#+end_src

** My_Editor
*** Meow
**** Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/meow/init.el :noweb yes :lexical nil
:END:

#+begin_src emacs-lisp
;;; editor/meow/init.el -*- lexical-binding: t; -*-
#+end_src
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/meow/packages.el :noweb yes :lexical nil
:END:
#+begin_src emacs-lisp
(package! meow)
(package! key-chord)
#+end_src
**** Checks
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/meow/doctor.el :lexical t :noweb yes
:END:
***** Doom Smartparens
#+begin_src emacs-lisp
(when (and (modulep! +parens) (not (modulep! :config  default +smartparens)))
  (warn! "The +parens flag of my_editor/meow is expected to be run with +smartparens flag of config/default, not doing so is undefined behavior")))
#+end_src
**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/meow/config.el :lexical t :noweb yes
:END:
#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

***** Meow
#+begin_src emacs-lisp
(use-package! meow
     :init
    (setq doom-leader-alt-key "C-c"
          doom-localleader-alt-key "H-l")

    (defvar meow-empty-state-map (define-keymap)
      "An empty keymap for when we don't want meow to be getting in the way")

    (meow-define-state empty
      "An empty keymap for when we don't want meow to be getting in the way"
      :lighter " [E]"
      :keymap meow-empty-state-map
      (message ""))

    :config
    (setq
     meow-keypad-self-insert-undefined nil
     meow-cheatsheet-layout meow-cheatsheet-layout-qwerty
     meow-use-clipboard t)
    (meow-global-mode 1)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))

    (meow-leader-define-key
     ;; SPC j/k will run the original command in motion state.
     '("SPC" . "H-SPC")
     '("j" . "H-j")
     '("k" . "H-k")
     ;; use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     ;; easy access utilities
     '(";" . "M-x")
     '(":" . "M-:")
     '("/" . meow-keypad-describe-key)
     '("l" . "H-l")
     '("?" . meow-cheatsheet))

    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("P" . yank-from-kill-ring)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))
 #+end_src

 #+RESULTS:

***** Key Chord
****** Quick Escape
#+begin_src emacs-lisp
  (use-package! key-chord
    :after meow
    :config
    (key-chord-mode 1)
    (key-chord-define-global "jk" 'meow-escape-or-normal-modal))
#+end_src
***** COMMENT Smartparens
#+begin_src emacs-lisp
(after! smartparens
  (define-keymap :keymap smartparens-mode-map
    "C-M-a"           #'sp-beginning-of-sexp
    "C-M-e"           #'sp-end-of-sexp
    "C-M-f"           #'sp-forward-sexp
    "C-M-b"           #'sp-backward-sexp
    "C-M-n"           #'sp-next-sexp
    "C-M-p"           #'sp-previous-sexp
    "C-M-u"           #'sp-up-sexp
    "C-M-d"           #'sp-down-sexp
    "C-M-k"           #'sp-kill-sexp
    "C-M-t"           #'sp-transpose-sexp
    "C-M-<backspace>" #'sp-splice-sexp))
#+end_src

*** Search
**** Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/search/packages.el :lexical t :noweb yes
:END:
#+begin_src emacs-lisp
(package! hyperspace)
#+end_src
**** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/my_editor/search/config.el :lexical t :noweb yes
:END:
***** Hyperspace
#+begin_src emacs-lisp
(use-package! hyperspace
  :demand t
  :init
  <<hyperspace-jira>>
  :bind
  (:map hyperspace-minor-mode-map
	    ("H-SPC" . #'hyperspace))
  :config
  (hyperspace-minor-mode 1)
  (setq hyperspace-actions
   '(("ddg" . "https://duckduckgo.com/?q=%s")
     ("gg" . "https://www.google.com/search?q=%s")
     ("ggm" . "https://www.google.com/maps/search/%s")
     ("gis" . "https://www.google.com/search?tbm=isch&q=%s")
     ("gh" . "https://github.com/search?q=%s&type=repositories")
     ("ghme" . "https://github.com/search?q=owner:CarsonHenrich&%s")
     ("wp" . "https://en.wikipedia.org/w/index.php?search=%s&title=Special:Search&go=Go")
     ("yt" . "https://www.youtube.com/results?search_query=%s")
     ("doc" . "https://devdocs.io/#q=%s")
     ("25" . "https://25live.collegenet.com/pro/wwu#!/home/search/location/calendar/&spaces_name=%s")
     ("jme" . (apply-partially #'hyperspace-action->jira-issues-with-query "assignee = currentUser() AND resolution = Unresolved"))
     ("jc" . (apply-partially #'hyperspace-action->jira-issues-with-query "project = HD AND resolution = Unresolved AND \'Assigned To Group\' = CENV"))
     ("jC" . (apply-partially #'hyperspace-action->jira-issues-with-query "project = HD AND \'Assigned To Group\' = CENV"))
     ("jj" . "https://wwuhelp.atlassian.net/issues/?filter=-1&jql=%s")
     ("man" . consult-man)
     ("man" . consult-man)
     ("af" lambda (query) (apropos-command query t))
     ("av" . apropos-variable)
     ("i" apply-partially #'hyperspace-action->info nil)
     ("el" apply-partially #'hyperspace-action->info "(elisp)Top"))))
#+end_src

****** Hyperspace Jira Query
#+begin_src emacs-lisp :noweb-ref hyperspace-jira :tangle no
(defvar ch/hyperspace-atlassian-url
  "https://wwuhelp.atlassian.net"
  "The site for the atlassian related actions")

(defvar ch/hyperspace-jira-issue-default-ordering
  "ORDER BY statusCategory ASC, priority DESC, updated DESC"
  "The default ordering for issues in jira queries")

(defconst ch/hyperspace-jira-issue-containing-text
  "AND text ~ \'%s\'")

(defun hyperspace-action->jira-issues-with-query (conditions &optional query &key ordering)
  "docstring"
  (interactive "P")
  (let ((ordering (or ordering ch/hyperspace-jira-issue-default-ordering)))
  (hyperspace-action->browse-url-pattern
   (concat
    ch/hyperspace-atlassian-url
    "/issues/?filter=-1&jql="
    conditions
    " "
    (when query
      (message query)
      ch/hyperspace-jira-issue-containing-text)
    " "
    ordering
    )
   query
   )))
#+end_src

#+RESULTS:
: hyperspace-action->jira-issues-with-query

* Packages
This is where packages not included in modules are placed to install them.
#+begin_src emacs-lisp :tangle packages.el
(package! all-the-icons)
(package! catppuccin-theme)
#+end_src

* Global Settings
** Personal Information

#+begin_src emacs-lisp
(setq user-full-name "Carson Henrich"
      user-mail-address "carson03henrich@gmail.com")
#+end_src

** Navigation
*** Workspaces
*** Windows
**** Defaults

#+begin_src emacs-lisp
(setq +popup-defaults
      (list
       :side   'bottom
       :height .42
       :width  90
       :quit   t
       :select t
       :ttl    5
       :slot nil
       :vslot nil
       :modeline nil
       :autosave nil
       :parameters '((transient . t) (no-other-window . t))))
#+end_src

**** Winner mode
#+begin_src emacs-lisp
(use-package! winner
  :ensure t
  :bind
  (:map global-map
	("C-c <left>" . winner-undo)
	("C-c <right>" . winner-redo))
  :init
  (winner-mode 1))
#+end_src
**** COMMENT Transpose
#+begin_src emacs-lisp :tangle packages.el
(package! transpose-frame)
#+end_src

#+begin_src emacs-lisp
(use-package! transpose-frame
  :bind
  ("C-x /" . #'transpose-frame))
#+end_src
** Editing
#+begin_src emacs-lisp
(toggle-text-mode-auto-fill)
#+end_src

** Popups
*** Defaults
#+begin_src emacs-lisp
(setq +popup-defaults
      (list
        :side   'bottom
        :height .42
        :width  90
        :quit   t
        :select t
        :ttl    5
        :slot nil
        :vslot nil
        :modeline nil
        :autosave nil
        :parameters '((transient . t) (no-other-window . t))))
#+end_src
*** Eglot
#+begin_src emacs-lisp
(use-package! eglot
  :config
  (set-popup-rule!
    "^\*eglot-help"
    :side 'bottom
    :size 0.15
    :width 0.15
    :height 0.42))
#+end_src
*** READMEs
#+begin_src emacs-lisp
(set-popup-rule!
  "README"
  :side 'right)
#+end_src
*** Man Pages
#+begin_src emacs-lisp
(set-popup-rule! "^\\*Man .*\\*" :side 'right :width 90)
#+end_src

** Completion
*** Corfu
#+begin_src emacs-lisp
(use-package! corfu
  :config
  (keymap-set corfu-map "M-TAB" #'+corfu/smart-sep-toggle-escape))
#+end_src
** Helpful

#+begin_src emacs-lisp
(use-package! helpful
  :config
  (setq
   counsel-describe-function-function #'helpful-callable
   counsel-describe-variable-function #'helpful-variable)
  (with-eval-after-load 'popper
    (add-to-list 'popper-reference-buffers 'helpful-mode)
    (popper-mode +1))
  (set-popup-rule! "^\\*\\([Hh]elp\\|Apropos\\)"
    :side 'right
    :slot 2
    :vslot -8
    :select t
    :parameters '((transient . t) (no-other-window . t)))
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command] . helpful-command)
  ([remap describe-key] . helpful-key))
#+end_src

* Keymaps
** Global
#+begin_src emacs-lisp
(define-keymap :keymap global-map
  "C-x b"       #'switch-to-buffer
  "C-x 4 b"     #'switch-to-buffer-other-window
  "C-x C-b"     #'ibuffer
  "C-x K"       #'doom/kill-this-buffer-in-all-windows
  ;; Windows
  "C-x C-h"     #'windmove-left
  "C-x C-j"     #'windmove-down
  "C-x C-k"     #'windmove-up
  "C-x C-l"     #'windmove-right
  "C-x C-d"     #'downcase-region ;; C-x C-l is `downcase-region' by defualt

; Swapping
  "C-x C-S-h"  #'windmove-swap-states-left
  "C-x C-S-j"  #'windmove-swap-states-down
  "C-x C-S-k"  #'windmove-swap-states-up
  "C-x C-S-l"  #'windmove-swap-states-right)

(when (modulep! :ui workspaces)
  (define-keymap :keymap global-map
    "C-x b"       #'persp-switch-to-buffer
    "C-x B"       #'switch-to-buffer
    "C-x 4 B"     #'switch-to-buffer-other-window))

(define-keymap :keymap global-map
  "C-'" #'imenu)

(when (modulep! :completion vertico)
  (define-keymap
    "C-S-r"        #'vertico-repeat))

(when (modulep! :ui popup)
  (define-keymap :keymap global-map
    "C-x p"   #'+popup/other
    "C-`"     #'+popup/toggle
    "C-~"     #'+popup/raise))
#+end_src
*** Leader Maps
**** Code
#+begin_src emacs-lisp
(defvar ch/code-map (make-sparse-keymap))

(keymap-set mode-specific-map "z" (cons "Code" ch/code-map))

(define-keymap :keymap ch/code-map
  "c"                               (cons "Compile"   #'compile)
  "C"                             (cons "Recompile"   #'recompile)
  "d"                    (cons "Jump to definition"   #'+lookup/definition)
  "D"                    (cons "Jump to references"   #'+lookup/references)
  "e"                (cons "Evaluate buffer/region"   #'+eval/buffer-or-region)
  "E"             (cons "Evaluate & replace region"   #'+eval/region-and-replace)
  "f"                  (cons "Format buffer/region"   #'+format/region-or-buffer)
  "i"                  (cons "Find implementations"   #'+lookup/implementations)
  "k"                 (cons "Jump to documentation"   #'+lookup/documentation)
  "s"                          (cons "Send to repl"   #'+eval/send-region-to-repl)
  "t"                  (cons "Find type definition"   #'+lookup/type-definition)
  "w"            (cons "Delete trailing whitespace"   #'delete-trailing-whitespace)
  "W"              (cons "Delete trailing newlines"   #'doom/delete-trailing-newlines)
  "x"                           (cons "List errors"   #'+default/diagnostics))

(when (modulep! :tools lsp +eglot)
  (define-keymap :keymap ch/code-map
    "a"              (cons "LSP Execute code action" #'eglot-code-actions)
    "r"                           (cons "LSP Rename" #'eglot-rename)
    "j"                 (cons "LSP Find declaration" #'eglot-find-declaration))
  (when (modulep! :completion vertico)
    (define-keymap :keymap ch/code-map
      "j" (cons "Jump to symbol in current workspace" #'consult-eglot-symbols))))
#+end_src
**** File
#+begin_src emacs-lisp
(defvar ch/file-map (make-sparse-keymap))

(keymap-set mode-specific-map "f" (cons "File" ch/file-map))

(define-keymap :keymap ch/file-map
  "C"              (cons "Copy this file"   #'doom/copy-this-file)
  "d"              (cons "Find directory"   #'dired)
  "D"            (cons "Delete this file"   #'doom/delete-this-file)
  "e"        (cons "Find file in emacs.d"   #'doom/find-file-in-emacsd)
  "E"              (cons "Browse emacs.d"   #'doom/browse-in-emacsd)
  "f"                   (cons "Find file"   #'find-file)
  "F"         (cons "Find file from here"   #'+default/find-file-under-here)
  "l"                 (cons "Locate file"   #'locate)
  "m"       (cons "Rename/move this file"   #'doom/move-this-file)
  "p" (cons "Find file in private config"   #'doom/find-file-in-private-config)
  "P"       (cons "Browse private config"   #'doom/open-private-config)
  "r"                (cons "Recent files"   #'recentf-open-files)
  "R"        (cons "Recent project files"   #'projectile-recentf)
  "u"              (cons "Sudo this file"   #'doom/sudo-this-file)
  "U"              (cons "Sudo find file"   #'doom/sudo-find-file)
  "y"              (cons "Yank file path"   #'+default/yank-buffer-path)
  "Y" (cons "Yank file path from project"   #'+default/yank-buffer-path-relative-to-project)
  "x"         (cons "Open scratch buffer"   #'doom/open-scratch-buffer)
  "X"    (cons "Switch to scratch buffer"   #'doom/switch-to-scratch-buffer))

(when (modulep!  editorconfig)
  (define-keymap :keymap ch/file-map
    "c"  (cons "Open project editorconfig"   #'editorconfig-find-current-editorconfig)))
#+end_src
**** Remote
#+begin_src emacs-lisp
(when (modulep! :tools upload)
  (defvar ch/remote-map (make-sparse-keymap))
  (keymap-set mode-specific-map "r" (cons "Remote" ch/remote-map))

  (define-keymap :keymap ch/remote-map
    "b"              (cons "Browse remote" #'ssh-deploy-browse-remote-base-handler)
    "B"            (cons "Browse relative" #'ssh-deploy-browse-remote-handler)
    "d"            (cons "Download remote" #'ssh-deploy-download-handler)
    "D"      (cons "Delete local & remote" #'ssh-deploy-delete-handler)
    "e"       (cons "Eshell base terminal" #'ssh-deploy-remote-terminal-eshell-base-handler)
    "E"   (cons "Eshell relative terminal" #'ssh-deploy-remote-terminal-eshell-handler)
    "m" (cons "Move/rename local & remote" #'ssh-deploy-rename-handler)
    "o"   (cons "Open this file on remote" #'ssh-deploy-open-remote-file-handler)
    "s"          (cons "Run deploy script" #'ssh-deploy-run-deploy-script-handler)
    "u"               (cons "Upload local" #'ssh-deploy-upload-handler)
    "U"       (cons "Upload local (force)" #'ssh-deploy-upload-handler-forced)
    "x"        (cons "Diff local & remote" #'ssh-deploy-diff-handler)
    "."        (cons "Browse remote files" #'ssh-deploy-browse-remote-handler)
    ">"      (cons "Detect remote changes" #'ssh-deploy-remote-changes-handle)))
#+end_src
**** Search
#+begin_src emacs-lisp
(defvar ch/search-map (make-sparse-keymap))

(keymap-set mode-specific-map "s" (cons "Search" ch/search-map))

(define-keymap :keymap ch/search-map
  "."    (cons "Search project for symbol" #'+default/search-project-for-symbol-at-point)
  "d"     (cons "Search current directory" #'+default/search-cwd)
  "D"       (cons "Search other directory" #'+default/search-other-cwd)
  "e"              (cons "Search .emacs.d" #'+default/search-emacsd)
  "f"                  (cons "Locate file" #'+lookup/file)
  "i"               (cons "Jump to symbol" #'imenu)
  "l"         (cons "Jump to visible link" #'link-hint-open-link)
  "L"                 (cons "Jump to link" #'ffap-menu)
  "m"                 (cons "Jump to mark" #'consult-mark)
  "M"             (cons "Jump to bookmark" #'bookmark-jump)
  "o"               (cons "Look up online" #'+lookup/online)
  "O"   (cons "Look up online (w/ prompt)" #'+lookup/online-select)
  "k"     (cons "Look up in local docsets" #'+lookup/in-docsets)
  "K"       (cons "Look up in all docsets" #'+lookup/in-all-docsets)
  "p"               (cons "Search project" #'+default/search-project)
  "P"         (cons "Search other project" #'+default/search-other-project)
  "s"                (cons "Search buffer" #'+default/search-buffer)
  "t"                   (cons "Dictionary" #'+lookup/dictionary-definition)
  "T"                    (cons "Thesaurus" #'+lookup/synonyms))

(when (modulep! :completion vertico)
  (define-keymap :keymap ch/search-map
    "b"                (cons "Search buffer" #'consult-line)
    "B"      (cons "Search all open buffers" (cmd!! #'consult-line-multi 'all-buffers))
    "I" (cons "Jump to symbol in open buffers" #'consult-imenu-multi)
    "S" (cons "Search buffer for thing at point" #'+vertico/search-symbol-at-point)))
#+end_src
**** Insert
#+begin_src emacs-lisp
(defvar ch/insert-map (make-sparse-keymap))

(keymap-set mode-specific-map "i"  (cons "insert" ch/insert-map))

(define-keymap :keymap ch/insert-map
  "f"   (cons "Current File Name" #'+default/insert-file-path)
  "F"   (cons "Current File Path" (cmd!! #'+default/insert-file-path t))
  "s"   (cons "Snippet"           #'yas-insert-snippet)
  "u"   (cons "Unicode"           #'insert-char)
  "y"   (cons "From Kill-Ring"    #'+default/yank-pop))

(when (> emacs-major-version 28)
  (define-keymap :keymap ch/insert-map
    "e"  (cons "Emoji" #'emoji-search)))
(when (modulep! :ui emoji)
  (define-keymap :keymap ch/insert-map
    "e"  (cons "Emoji" #'emojify-insert-emoji)))
#+end_src
**** Open
#+begin_src emacs-lisp
(defvar ch/open-map (make-sparse-keymap))

(keymap-set mode-specific-map "o" (cons "Open" ch/open-map))

(define-keymap :keymap ch/open-map
  "b"            (cons "Browser"  #'browse-url-of-file)
  "d"           (cons "Debugger"  #'+debugger/start)
  "f"          (cons "New frame"  #'make-frame)
  "r"               (cons "REPL"  #'+eval/open-repl-other-window)
  "R" (cons "REPL (same window)"  #'+eval/open-repl-same-window)
  "-"              (cons "Dired"  #'dired-jump))

(when (modulep! :term eshell)
  (define-keymap :keymap ch/open-map
    "e"           (cons "Toggle eshell popup" #'+eshell/toggle)
    "E"              (cons "Open eshell here" #'+eshell/here)
    ))

(when (modulep! :term vterm)
  (define-keymap :keymap ch/open-map
    "t"            (cons "Toggle vterm popup" #'+vterm/toggle)
    "T"               (cons "Open vterm here" #'+vterm/here)
    ))

(when (modulep! :emacs dired +dirvish)
  (define-keymap :keymap ch/open-map
    "/"     (cons "Open directory in dirvish" #'dirvish)
    "p"               (cons "Project sidebar" #'dirvish-side)
    "P"  (cons "Find file in project sidebar" #'+dired/dirvish-side-and-follow)
    ))

(when (modulep! :tools docker)
  (define-keymap :keymap ch/open-map
    "D" (cons "Docker" #'docker)
    ))

(when (modulep! :email mu4e)
  (define-keymap :keymap ch/open-map
    "m" (cons "Mu4e" #'=mu4e)
    ))

(when (modulep! :app irc)
  (define-keymap :keymap ch/open-map
    "i" (cons "IRC" #'=irc)
    ))

(when (modulep! :app rss)
  (define-keymap :keymap ch/open-map
    "n" (cons "News (RSS)" #'=rss)
    ))

(when (modulep! :os macos)
  (define-keymap :keymap ch/open-map
    "o" (cons          "Reveal in Finder" #'+macos/reveal-in-finder)
    "O" (cons  "Reveal project in Finder" #'+macos/reveal-project-in-finder)
    ))
#+end_src
**** Snippets
#+begin_src emacs-lisp
(defvar ch/snippet-map (make-sparse-keymap))

(keymap-set mode-specific-map "S" (cons "Snippets" ch/snippet-map))

(define-keymap :keymap ch/snippet-map
  "n"           (cons "New snippet" #'yas-new-snippet)
  "i"        (cons "Insert snippet" #'yas-insert-snippet)
  "/"   (cons "Find global snippet" #'yas-visit-snippet-file)
  "r"       (cons "Reload snippets" #'yas-reload-all)
  "c"  (cons "Create Temp Template" #'aya-create)
  "e"     (cons "Use Temp Template" #'aya-expand))
#+end_src
**** Quit
#+begin_src emacs-lisp
(defvar ch/quit-map (make-sparse-keymap))

(keymap-set mode-specific-map "q" (cons "Quit" ch/quit-map))

(define-keymap :keymap ch/quit-map
  "d"         (cons "Restart emacs server" #'+default/restart-server)
  "f"                 (cons "Delete frame" #'delete-frame)
  "F"          (cons "Clear current frame" #'doom/kill-all-buffers)
  "K"      (cons "Kill Emacs (and daemon)" #'save-buffers-kill-emacs)
  "q"                   (cons "Quit Emacs" #'kill-emacs)
  "Q"          (cons "Save and quit Emacs" #'save-buffers-kill-terminal)
  "s"   (cons "Quick save current session" #'doom/quicksave-session)
  "l"         (cons "Restore last session" #'doom/quickload-session)
  "S"         (cons "Save session to file" #'doom/save-session)
  "L"    (cons "Restore session from file" #'doom/load-session)
  "r"      (cons "Restart & restore Emacs" #'doom/restart-and-restore)
  "R"                (cons "Restart Emacs" #'doom/restart))
#+end_src
**** Windows
#+begin_src emacs-lisp
(defvar ch/window-map (make-sparse-keymap))
(define-keymap :keymap global-map "C-TAB" (cons "Switch Window" #'ace-window))
(keymap-set mode-specific-map "w" (cons "Window" ch/window-map))

(define-keymap :keymap ch/window-map
  "d"   (cons "Delete" #'ace-delete-window)
  "D"   (cons "Delete Others" #'ace-delete-other-windows)
  "w"   (cons "Switch" #'ace-window)
  "W"   (cons "Swap" #'ace-swap-window)

  "h"   (cons "Switch Left" #'windmove-left)
  "H"   (cons "Swap Left" #'windmove-swap-states-left)
  "l"   (cons "Switch Right" #'windmove-right)
  "L"   (cons "Swap Right" #'windmove-swap-states-right)
  "k"   (cons "Switch Up" #'windmove-up)
  "K"   (cons "Swap Up" #'windmove-swap-states-up)
  "j"   (cons "Switch Down" #'windmove-down)
  "J"   (cons "Swap Down" #'windmove-swap-states-down)
  )
#+end_src
**** Projects
#+begin_src emacs-lisp
(defvar ch/project-map (make-sparse-keymap))

(require 'projectile)
(set-keymap-parent ch/project-map projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

(keymap-set mode-specific-map "p" (cons "Project" ch/project-map))
(keymap-set ch/project-map "4" (cons "Other Window" project-other-window-map))
(keymap-set ch/project-map "5" (cons "Other Frame" project-other-frame-map))

(define-keymap :keymap ch/project-map
  "."   (cons "Search project for symbol" #'+default/search-project-for-symbol-at-point)
  "F"  (cons "Find file in other project" #'doom/find-file-in-other-project)
  "s"              (cons "Search project" #'+default/search-project)
  "x" (cons "Open project scratch buffer" #'doom/open-project-scratch-buffer)
  "X" (cons "Switch to project scratch buffer" #'doom/switch-to-project-scratch-buffer)
  )
#+end_src
**** Workspaces
#+begin_src emacs-lisp
  (defvar ch/workspace-map (make-sparse-keymap))

  (after! persp-mode
    (setq! persp-keymap-prefix (kbd "C-c TAB")))


  (keymap-set mode-specific-map "TAB" (cons "Workspaces" ch/workspace-map))

  (define-keymap :keymap ch/workspace-map
    "d"           (cons "Display workspaces" #'+workspace/display)
    "r"             (cons "Rename workspace" #'+workspace/rename)
    "c"             (cons "Create workspace" #'+workspace/new)
    "C"       (cons "Create named workspace" #'+workspace/new-named)
    "k"             (cons "Delete workspace" #'+workspace/kill)
    "K"       (cons "Delete saved workspace" #'+workspace/delete)
    "S"               (cons "Save workspace" #'+workspace/save)
    "o"    (cons "Switch to other workspace" #'+workspace/other)
    "p"     (cons "Switch to left workspace" #'+workspace/switch-left)
    "n"    (cons "Switch to right workspace" #'+workspace/switch-right)
    "TAB"                  (cons "Switch to" #'+workspace/switch-to)
    "1"        (cons "Switch to workspace 1" #'+workspace/switch-to-0)
    "2"        (cons "Switch to workspace 2" #'+workspace/switch-to-1)
    "3"        (cons "Switch to workspace 3" #'+workspace/switch-to-2)
    "4"        (cons "Switch to workspace 4" #'+workspace/switch-to-3)
    "5"        (cons "Switch to workspace 5" #'+workspace/switch-to-4)
    "6"        (cons "Switch to workspace 6" #'+workspace/switch-to-5)
    "7"        (cons "Switch to workspace 7" #'+workspace/switch-to-6)
    "8"        (cons "Switch to workspace 8" #'+workspace/switch-to-7)
    "9"        (cons "Switch to workspace 9" #'+workspace/switch-to-8)
    "0"     (cons "Switch to last workspace" #'+workspace/switch-to-final)
    "a"             (cons "Autosave session" #'doom/quicksave-session)
    "s"                 (cons "Save session" #'doom/save-session)
    "l"                 (cons "Load session" #'doom/load-session)
    "L"  (cons "Load last autosaved session" #'doom/quickload-session)
    )
#+end_src
**** Toggle
#+begin_src emacs-lisp
(defvar ch/toggle-map (make-sparse-keymap))

(keymap-set mode-specific-map "t" (cons "Toggle" ch/toggle-map))

(define-keymap :keymap ch/toggle-map
  "b"                     (cons "Big mode" #'doom-big-font-mode)
  "c"        (cons "Fill Column Indicator" #'global-display-fill-column-indicator-mode)
  "f"                      (cons "Flymake" #'flymake-mode)
  "F"             (cons "Frame fullscreen" #'toggle-frame-fullscreen)
  "I"                 (cons "Indent style" #'doom/toggle-indent-style)
  "l"                 (cons "Line numbers" #'doom/toggle-line-numbers)
  "v"                 (cons "Visible mode" #'visible-mode)
  "w"           (cons "Soft line wrapping" #'visual-line-mode)
  "r"               (cons "Read-only mode" #'read-only-mode))

(when (modulep! :ui minimap)
  (define-keymap :keymap ch/toggle-map
    "m"               (cons "Minimap mode" #'minimap-mode)))
(when (modulep! :checkers syntax)
  (define-keymap :keymap ch/toggle-map
    "f"                    (cons "Flycheck" #'flycheck-mode)))
(when (modulep! :ui indent-guides)
  (define-keymap :keymap ch/toggle-map
    "i"              (cons "Indent guides"  #'indent-bars-mode)))
(when (modulep! :editor word-wrap)
  (define-keymap :keymap ch/toggle-map
    "w"          (cons "Soft line wrapping" #'+word-wrap-mode)))
(when (modulep! :checkers spell +flyspell)
  (define-keymap :keymap ch/toggle-map
    "s"              (cons "Spell checker" #'flyspell-mode)))
(when (modulep! :lang org +pomodoro)
  (define-keymap :keymap ch/toggle-map
    "t"             (cons "Pomodoro timer" #'org-pomodoro)))
(when (modulep! :ui zen)
  (define-keymap :keymap ch/toggle-map
    "z"                   (cons "Zen mode" #'+zen/toggle)
    "Z"      (cons "Zen mode (fullscreen)" #'+zen/toggle-fullscreen)))
#+end_src
**** Fold
#+begin_src emacs-lisp
(when (modulep! :editor fold)
  (defvar ch/fold-map (make-sparse-keymap))

  (keymap-set mode-specific-map "C-f" (cons "Fold" ch/fold-map))

  (define-keymap :keymap ch/fold-map
    "C-d"     #'vimish-fold-delete
    "C-a C-d" #'vimish-fold-delete-all
    "C-f"     #'+fold/toggle
    "C-a C-f" #'+fold/close-all
    "C-u"     #'+fold/open
    "C-a C-u" #'+fold/open-all))
#+end_src
**** Multiple Cursors
#+begin_src emacs-lisp
(when (modulep! :editor multiple-cursors)
  (defvar ch/multicursor-map (make-sparse-keymap))

  (keymap-set mode-specific-map "u" (cons "Multi-Cursor" ch/multicursor-map))

  (define-keymap :keymap ch/multicursor-map
    "l"         (cons "Edit lines"         #'mc/edit-lines)
    "n"          (cons "Mark next"         #'mc/mark-next-like-this)
    "N"        (cons "Unmark next"         #'mc/unmark-next-like-this)
    "p"      (cons "Mark previous"         #'mc/mark-previous-like-this)
    "P"    (cons "Unmark previous"         #'mc/unmark-previous-like-this)
    "t"           (cons "Mark all"         #'mc/mark-all-like-this)
    "m"      (cons "Mark all DWIM"         #'mc/mark-all-like-this-dwim)
    "e"  (cons "Edit line endings"         #'mc/edit-ends-of-lines)
    "a"   (cons "Edit line starts"         #'mc/edit-beginnings-of-lines)
    "s"           (cons "Mark tag"         #'mc/mark-sgml-tag-pair)
    "d"      (cons "Mark in defun"         #'mc/mark-all-like-this-in-defun)
    "<mouse-1>" (cons "Add cursor w/mouse" #'mc/add-cursor-on-click)))
#+end_src
**** Versioning
#+begin_src emacs-lisp
(defvar ch/version-map (make-sparse-keymap))

(keymap-set mode-specific-map "v" (cons "Version" ch/version-map))

(define-keymap :keymap ch/version-map
  "R"             (cons "Git revert file"   #'vc-revert)
  "y"         (cons "Kill link to remote"   #'+vc/browse-at-remote-kill)
  "Y"       (cons "Kill link to homepage"   #'+vc/browse-at-remote-kill-homepage))

(when (modulep! :tools magit)
  (defvar ch/magit-create-map (make-sparse-keymap))
  (defvar ch/magit-list-map (make-sparse-keymap))
  (defvar ch/magit-find-map (make-sparse-keymap))
  (defvar ch/magit-browse-map (make-sparse-keymap))

  (define-keymap :keymap ch/version-map
    "/"             (cons "Magit dispatch"   #'magit-dispatch)
    "."        (cons "Magit file dispatch"   #'magit-file-dispatch)
    "'"             (cons "Forge dispatch"   #'forge-dispatch)
    "g"               (cons "Magit status"   #'magit-status)
    "G"          (cons "Magit status here"   #'magit-status-here)
    "x"          (cons "Magit file delete"   #'magit-file-delete)
    "B"                (cons "Magit blame"   #'magit-blame-addition)
    "C"                (cons "Magit clone"   #'magit-clone)
    "F"                (cons "Magit fetch"   #'magit-fetch)
    "L"           (cons "Magit buffer log"   #'magit-log-buffer-file)
    "S"             (cons "Git stage file"   #'magit-stage-file)
    "U"           (cons "Git unstage file"   #'magit-unstage-file)
    "f"                       (cons "Find"   ch/magit-find-map)
    "c"                     (cons "Create"   ch/magit-create-map)
    "b"                     (cons "Browse"   ch/magit-browse-map)
    "l"                       (cons "List"   ch/magit-list-map))

  (define-keymap :keymap ch/magit-find-map
    "f"                 (cons "Find file"   #'magit-find-file)
    "g"       (cons "Find gitconfig file"   #'magit-find-git-config-file)
    "c"               (cons "Find commit"   #'magit-show-commit)
    "i"                (cons "Find issue"   #'forge-visit-issue)
    "p"         (cons "Find pull request"   #'forge-visit-pullreq))

  (define-keymap :keymap ch/magit-browse-map
    "."     (cons "Browse file or region"   #'+vc/browse-at-remote)
    "h"           (cons "Browse homepage"   #'+vc/browse-at-remote-homepage)
    "r"             (cons "Browse remote"   #'forge-browse-remote)
    "c"             (cons "Browse commit"   #'forge-browse-commit)
    "i"           (cons "Browse an issue"   #'forge-browse-issue)
    "p"     (cons "Browse a pull request"   #'forge-browse-pullreq)
    "I"             (cons "Browse issues"   #'forge-browse-issues)
    "P"      (cons "Browse pull requests"   #'forge-browse-pullreqs))

  (define-keymap :keymap ch/magit-create-map
    "r"           (cons "Initialize repo"   #'magit-init)
    "R"                (cons "Clone repo"   #'magit-clone)
    "c"                    (cons "Commit"   #'magit-commit-create)
    "f"                     (cons "Fixup"   #'magit-commit-fixup)
    "i"                     (cons "Issue"   #'forge-create-issue)
    "p"              (cons "Pull request"   #'forge-create-pullreq))

  (define-keymap :keymap ch/magit-list-map
    "r"         (cons "List repositories"   #'magit-list-repositories)
    "s"           (cons "List submodules"   #'magit-list-submodules)
    "i"               (cons "List issues"   #'forge-list-issues)
    "p"        (cons "List pull requests"   #'forge-list-pullreqs)
    "n"        (cons "List notifications"   #'forge-list-notifications)))

(when (modulep! :ui vc-gutter)
  (define-keymap :keymap ch/version-map
    "r"            (cons "Git revert hunk"   #'+vc-gutter/revert-hunk)
    "s"             (cons "Git stage hunk"   #'+vc-gutter/stage-hunk)
    "t"           (cons "Git time machine"   #'git-timemachine-toggle)
    "n"          (cons "Jump to next hunk"   #'+vc-gutter/next-hunk)
    "p"      (cons "Jump to previous hunk"   #'+vc-gutter/previous-hunk)))
#+end_src
** Flycheck
#+begin_src emacs-lisp
(after! flycheck
  (define-keymap :keymap flycheck-error-list-mode-map
    "C-n" #'flycheck-error-list-next-error
    "C-p" #'flycheck-error-list-previous-error
    "RET" #'flycheck-error-list-goto-error))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(after! smartparens
  (define-keymap :keymap smartparens-mode-map
    "C-M-a"           #'sp-beginning-of-sexp
    "C-M-e"           #'sp-end-of-sexp
    "C-M-f"           #'sp-forward-sexp
    "C-M-b"           #'sp-backward-sexp
    "C-M-n"           #'sp-next-sexp
    "C-M-p"           #'sp-previous-sexp
    "C-M-u"           #'sp-up-sexp
    "C-M-d"           #'sp-down-sexp
    "C-M-k"           #'sp-kill-sexp
    "C-M-t"           #'sp-transpose-sexp
    "C-M-<backspace>" #'sp-splice-sexp))

#+end_src
** Help Modes
#+begin_src emacs-lisp
(after! help-mode
  (define-keymap :keymap help-mode-map
    "o" #'link-hint-open-link
    ">" #'help-go-forward
    "<" #'help-go-back
    "n" #'forward-button
    "p" #'backward-button))
(after! apropos
  (define-keymap :keymap apropos-mode-map
    "o" #'link-hint-open-link
    "n" #'forward-button
    "p" #'backward-button))
(after! info
  (define-keymap :keymap Info-mode-map
    "o" #'link-hint-open-link))
#+end_src
** Dired
#+begin_src emacs-lisp
(define-keymap :keymap dired-mode-map
  "[" #'dired-prev-dirline
  "]" #'dired-next-dirline
  "." #'dired-omit-mode
  "N" #'dired-create-empty-file
  "<" #'dired-omit-expunge
  ">" #'ignore
  "l" #'dired-find-file
  "h" #'dired-up-directory)

(when (modulep! :emacs dired +dirvish)
  (define-keymap :keymap dired-mode-map
  "{" #'dirvish-subtree-up
  "TAB" #'dirvish-subtree-toggle))
#+end_src
** Repeat

#+begin_src emacs-lisp
(repeat-mode 1)
#+end_src

** COMMENT Which-key

#+begin_src emacs-lisp
  (use-package which-key
    :functions which-key-mode
    :bind
    ("C-h C-b" . describe-bindings)
    ("C-h b" . which-key-show-top-level)
    :init (which-key-mode 1)
    :diminish which-key-mode
    :config (setq which-key-idle-delay 0.3))
#+end_src

** COMMENT Mini-buffer Keymaps

#+begin_src emacs-lisp
  (define-keymap :keymap minibuffer-mode-map
    "M-/" #'consult-history
    "M-<up>" #'next-history-element
    "M-<down>" #'previous-history-element)
#+end_src
* Mode Specific Settings
** Dired/Dirvish
#+begin_src emacs-lisp
(use-package! dirvish
  :config
  (setq dirvish-side-auto-close t))
#+end_src
* Appearance
** COMMENT Setting Sane Defaults
Just getting rid of some of the default appearance of Emacs
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq inhibit-startup-message t)
  (setq use-dialog-box nil)
  (global-hl-line-mode)
#+end_src

Setting a transparent blank title-bar
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (setq ns-use-proxy-icon nil)
  (setq frame-title-format nil)
#+end_src

*** Line Numbers
Turn on the display of line and column numbers in the mode-line also when
displaying line numbers do so relatively for ease of motion commands.
#+begin_src emacs-lisp
  (column-number-mode 1)
  (global-display-line-numbers-mode 1)
  (setq display-line-numbers-type 'relative)
#+end_src

Disable line numbers for the listed modes, typically just modes where it doesn't
really make sense to have line numbers cluttering the buffer.
#+begin_src emacs-lisp
  (dolist (hook '(eshell-mode-hook
		  org-mode-hook
		  mu4e-main-mode-hook
		  mu4e-headers-mode-hook
		  term-mode-hook))
    (add-hook hook (lambda () (display-line-numbers-mode 0))))
#+end_src

** UI
*** Theme
Configuring and requiring the theme
#+begin_src emacs-lisp
(use-package! catppuccin-theme
  :config
  (setq catppuccin-flavor 'mocha)
  (load-theme 'catppuccin :no-confirm))
#+end_src

*** Mode-line
#+begin_src emacs-lisp
(use-package! doom-modeline
  :after all-the-icons
  :functions doom-modeline-mode
  :init (doom-modeline-mode 1)
  :config
  ;; Display the time on the mode-line.
  (display-time-mode 1)
  (setq
   display-time-format "%Y-%m-%d %H:%M"
   doom-modeline-height 15
   doom-modeline-enable-word-count t))
#+end_src

#+begin_src emacs-lisp
(use-package! all-the-icons)
#+end_src

** Visual Fill Column
#+begin_src emacs-lisp
(use-package! visual-fill-column
  ;;TODO :bind (:map ch/toggle-map
  ;;     	("v" . visual-fill-column-mode))
  :config
  (setq
   visual-fill-column-center-text t
   visual-fill-column-width 130
   visual-fill-column-enable-sensible-window-split t))
#+end_src
** Fonts
#+begin_src emacs-lisp
;; Set reusable font name variables
(defvar ch/fixed-width-font "Iosevka Nerd Font Mono" "The font to use for monospaced (fixed width) text.")
(defvar ch/variable-width-font "Iosevka Aile" "The font to use for variable-pitch (document) text.")


(setq doom-font (font-spec :family ch/fixed-width-font :size 14 :weight 'medium))
(setq doom-big-font (font-spec :family ch/fixed-width-font :size 24 :weight 'medium))
(setq doom-variable-pitch-font (font-spec :family ch/variable-width-font))

(set-frame-font (font-spec :family ch/fixed-width-font  :size 14 :weight 'medium))
(set-face-attribute 'fixed-pitch    nil :font ch/fixed-width-font    :height 1.0 :weight 'medium)
#+end_src

* Hacks
As we all know sometimes you just need a quick fix not a permenant solution those go here.
** COMMENT Parinfer on MacOS
~rust-parinfer~ compiles only for apple silicon through GitHub CI see [[https://github.com/justinbarclay/parinfer-rust-mode/issues/43][here]] for more info
#+begin_src emacs-lisp
(setq parinfer-rust-library (expand-file-name "lib/libparinfer_rust.dylib.so" user-emacs-directory))
#+end_src

** Which-key for Meow Keypad
For whatever reason which-key suddenly stopped working with [[Meow]]s keypad mode
but this seems to fix the problem while I'm too lazy to actually figure it out.
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
	  #'(lambda () (progn (which-key-mode -1)(which-key-mode 1))))
#+end_src
** Yubikey + Magit
#+begin_src emacs-lisp
(setenv "SSH_AUTH_SOCK" (string-chop-newline (shell-command-to-string "gpgconf --list-dirs agent-ssh-socket")))

#+end_src
** COMMENT Dired Super Slow
Dired is unusably slow if I enable this for some reason
#+begin_src emacs-lisp
(after! diff-hl
  (global-diff-hl-mode -1)
  (remove-hook 'dired-mode-hook '+vc-gutter-enable-maybe-h))
#+end_src
* Workspace
** Just
#+begin_src emacs-lisp :tangle packages.el
(package! just-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! just-mode)
#+end_src
** Android
#+begin_src emacs-lisp :tangle packages.el
(package! android-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! android-mode
  :init
  (setq android-mode-sdk-dir (f-base (executable-find "avdmanager"))))
#+end_src
** Ledger
#+begin_src emacs-lisp :tangle packages.el
(package! ledger-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! ledger-mode
  :mode ("\\.dat\\'"
         "\\.ledger\\'")
  :bind (:map ledger-mode-map
	("C-x C-s" . ch/ledger-save))
  :preface
  (defun ch/ledger-save ()
    "Automatically clean the ledger buffer at each save."
    (interactive)
    (save-excursion
      (when (buffer-modified-p)
        (with-demoted-errors (ledger-mode-clean-buffer))
        (save-buffer)))))
#+end_src
